(self.webpackChunknpwd_nui=self.webpackChunknpwd_nui||[]).push([[660],{96481:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar helpers = __webpack_require__(59177);\n\n/** @type ValidatorResult */\nvar ValidatorResult = helpers.ValidatorResult;\n/** @type SchemaError */\nvar SchemaError = helpers.SchemaError;\n\nvar attribute = {};\n\nattribute.ignoreProperties = {\n  // informative properties\n  'id': true,\n  'default': true,\n  'description': true,\n  'title': true,\n  // arguments to other properties\n  'additionalItems': true,\n  'then': true,\n  'else': true,\n  // special-handled properties\n  '$schema': true,\n  '$ref': true,\n  'extends': true,\n};\n\n/**\n * @name validators\n */\nvar validators = attribute.validators = {};\n\n/**\n * Validates whether the instance if of a certain type\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.type = function validateType (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var types = Array.isArray(schema.type) ? schema.type : [schema.type];\n  if (!types.some(this.testType.bind(this, instance, schema, options, ctx))) {\n    var list = types.map(function (v) {\n      if(!v) return;\n      var id = v.$id || v.id;\n      return id ? ('<' + id + '>') : (v+'');\n    });\n    result.addError({\n      name: 'type',\n      argument: list,\n      message: \"is not of a type(s) \" + list,\n    });\n  }\n  return result;\n};\n\nfunction testSchemaNoThrow(instance, options, ctx, callback, schema){\n  var throwError = options.throwError;\n  var throwAll = options.throwAll;\n  options.throwError = false;\n  options.throwAll = false;\n  var res = this.validateSchema(instance, schema, options, ctx);\n  options.throwError = throwError;\n  options.throwAll = throwAll;\n\n  if (!res.valid && callback instanceof Function) {\n    callback(res);\n  }\n  return res.valid;\n}\n\n/**\n * Validates whether the instance matches some of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {ValidatorResult|null}\n */\nvalidators.anyOf = function validateAnyOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  if (!Array.isArray(schema.anyOf)){\n    throw new SchemaError(\"anyOf must be an array\");\n  }\n  if (!schema.anyOf.some(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res){inner.importErrors(res);}\n    ))) {\n    var list = schema.anyOf.map(function (v, i) {\n      var id = v.$id || v.id;\n      if(id) return '<' + id + '>';\n      return(v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n    });\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'anyOf',\n      argument: list,\n      message: \"is not any of \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance matches every given schema\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.allOf = function validateAllOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.allOf)){\n    throw new SchemaError(\"allOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var self = this;\n  schema.allOf.forEach(function(v, i){\n    var valid = self.validateSchema(instance, v, options, ctx);\n    if(!valid.valid){\n      var id = v.$id || v.id;\n      var msg = id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n      result.addError({\n        name: 'allOf',\n        argument: { id: msg, length: valid.errors.length, valid: valid },\n        message: 'does not match allOf schema ' + msg + ' with ' + valid.errors.length + ' error[s]:',\n      });\n      result.importErrors(valid);\n    }\n  });\n  return result;\n};\n\n/**\n * Validates whether the instance matches exactly one of the given schemas\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.oneOf = function validateOneOf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema.oneOf)){\n    throw new SchemaError(\"oneOf must be an array\");\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var inner = new ValidatorResult(instance, schema, options, ctx);\n  var count = schema.oneOf.filter(\n    testSchemaNoThrow.bind(\n      this, instance, options, ctx, function(res) {inner.importErrors(res);}\n    ) ).length;\n  var list = schema.oneOf.map(function (v, i) {\n    var id = v.$id || v.id;\n    return id || (v.title && JSON.stringify(v.title)) || (v['$ref'] && ('<' + v['$ref'] + '>')) || '[subschema '+i+']';\n  });\n  if (count!==1) {\n    if (options.nestedErrors) {\n      result.importErrors(inner);\n    }\n    result.addError({\n      name: 'oneOf',\n      argument: list,\n      message: \"is not exactly one from \" + list.join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates \"then\" or \"else\" depending on the result of validating \"if\"\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null}\n */\nvalidators.if = function validateIf (instance, schema, options, ctx) {\n  // Ignore undefined instances\n  if (instance === undefined) return null;\n  if (!helpers.isSchema(schema.if)) throw new Error('Expected \"if\" keyword to be a schema');\n  var ifValid = testSchemaNoThrow.call(this, instance, options, ctx, null, schema.if);\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var res;\n  if(ifValid){\n    if (schema.then === undefined) return;\n    if (!helpers.isSchema(schema.then)) throw new Error('Expected \"then\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.then, options, ctx.makeChild(schema.then));\n    result.importErrors(res);\n  }else{\n    if (schema.else === undefined) return;\n    if (!helpers.isSchema(schema.else)) throw new Error('Expected \"else\" keyword to be a schema');\n    res = this.validateSchema(instance, schema.else, options, ctx.makeChild(schema.else));\n    result.importErrors(res);\n  }\n  return result;\n};\n\nfunction getEnumerableProperty(object, key){\n  // Determine if `key` shows up in `for(var key in object)`\n  // First test Object.hasOwnProperty.call as an optimization: that guarantees it does\n  if(Object.hasOwnProperty.call(object, key)) return object[key];\n  // Test `key in object` as an optimization; false means it won't\n  if(!(key in object)) return;\n  while( (object = Object.getPrototypeOf(object)) ){\n    if(Object.propertyIsEnumerable.call(object, key)) return object[key];\n  }\n}\n\n/**\n * Validates propertyNames\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.propertyNames = function validatePropertyNames (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var subschema = schema.propertyNames!==undefined ? schema.propertyNames : {};\n  if(!helpers.isSchema(subschema)) throw new SchemaError('Expected \"propertyNames\" to be a schema (object or boolean)');\n\n  for (var property in instance) {\n    if(getEnumerableProperty(instance, property) !== undefined){\n      var res = this.validateSchema(property, subschema, options, ctx.makeChild(subschema));\n      result.importErrors(res);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates properties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.properties = function validateProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var properties = schema.properties || {};\n  for (var property in properties) {\n    var subschema = properties[property];\n    if(subschema===undefined){\n      continue;\n    }else if(subschema===null){\n      throw new SchemaError('Unexpected null, expected schema in \"properties\"');\n    }\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, subschema, options, ctx);\n    }\n    var prop = getEnumerableProperty(instance, property);\n    var res = this.validateSchema(prop, subschema, options, ctx.makeChild(subschema, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n  return result;\n};\n\n/**\n * Test a specific property within in instance against the additionalProperties schema attribute\n * This ignores properties with definitions in the properties schema attribute, but no other attributes.\n * If too many more types of property-existence tests pop up they may need their own class of tests (like `type` has)\n * @private\n * @return {boolean}\n */\nfunction testAdditionalProperty (instance, schema, options, ctx, property, result) {\n  if(!this.types.object(instance)) return;\n  if (schema.properties && schema.properties[property] !== undefined) {\n    return;\n  }\n  if (schema.additionalProperties === false) {\n    result.addError({\n      name: 'additionalProperties',\n      argument: property,\n      message: \"is not allowed to have the additional property \" + JSON.stringify(property),\n    });\n  } else {\n    var additionalProperties = schema.additionalProperties || {};\n\n    if (typeof options.preValidateProperty == 'function') {\n      options.preValidateProperty(instance, property, additionalProperties, options, ctx);\n    }\n\n    var res = this.validateSchema(instance[property], additionalProperties, options, ctx.makeChild(additionalProperties, property));\n    if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n    result.importErrors(res);\n  }\n}\n\n/**\n * Validates patternProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.patternProperties = function validatePatternProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var patternProperties = schema.patternProperties || {};\n\n  for (var property in instance) {\n    var test = true;\n    for (var pattern in patternProperties) {\n      var subschema = patternProperties[pattern];\n      if(subschema===undefined){\n        continue;\n      }else if(subschema===null){\n        throw new SchemaError('Unexpected null, expected schema in \"patternProperties\"');\n      }\n      try {\n        var regexp = new RegExp(pattern, 'u');\n      } catch(_e) {\n        // In the event the stricter handling causes an error, fall back on the forgiving handling\n        // DEPRECATED\n        regexp = new RegExp(pattern);\n      }\n      if (!regexp.test(property)) {\n        continue;\n      }\n      test = false;\n\n      if (typeof options.preValidateProperty == 'function') {\n        options.preValidateProperty(instance, property, subschema, options, ctx);\n      }\n\n      var res = this.validateSchema(instance[property], subschema, options, ctx.makeChild(subschema, property));\n      if(res.instance !== result.instance[property]) result.instance[property] = res.instance;\n      result.importErrors(res);\n    }\n    if (test) {\n      testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Validates additionalProperties\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.additionalProperties = function validateAdditionalProperties (instance, schema, options, ctx) {\n  if(!this.types.object(instance)) return;\n  // if patternProperties is defined then we'll test when that one is called instead\n  if (schema.patternProperties) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in instance) {\n    testAdditionalProperty.call(this, instance, schema, options, ctx, property, result);\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minProperties = function validateMinProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length >= schema.minProperties)) {\n    result.addError({\n      name: 'minProperties',\n      argument: schema.minProperties,\n      message: \"does not meet minimum property length of \" + schema.minProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxProperties = function validateMaxProperties (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var keys = Object.keys(instance);\n  if (!(keys.length <= schema.maxProperties)) {\n    result.addError({\n      name: 'maxProperties',\n      argument: schema.maxProperties,\n      message: \"does not meet maximum property length of \" + schema.maxProperties,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates items when instance is an array\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {String|null|ValidatorResult}\n */\nvalidators.items = function validateItems (instance, schema, options, ctx) {\n  var self = this;\n  if (!this.types.array(instance)) return;\n  if (!schema.items) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  instance.every(function (value, i) {\n    var items = Array.isArray(schema.items) ? (schema.items[i] || schema.additionalItems) : schema.items;\n    if (items === undefined) {\n      return true;\n    }\n    if (items === false) {\n      result.addError({\n        name: 'items',\n        message: \"additionalItems not permitted\",\n      });\n      return false;\n    }\n    var res = self.validateSchema(value, items, options, ctx.makeChild(items, i));\n    if(res.instance !== result.instance[i]) result.instance[i] = res.instance;\n    result.importErrors(res);\n    return true;\n  });\n  return result;\n};\n\n/**\n * Validates minimum and exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minimum = function validateMinimum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMinimum && schema.exclusiveMinimum === true) {\n    if(!(instance > schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than \" + schema.minimum,\n      });\n    }\n  } else {\n    if(!(instance >= schema.minimum)){\n      result.addError({\n        name: 'minimum',\n        argument: schema.minimum,\n        message: \"must be greater than or equal to \" + schema.minimum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates maximum and exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maximum = function validateMaximum (instance, schema, options, ctx) {\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (schema.exclusiveMaximum && schema.exclusiveMaximum === true) {\n    if(!(instance < schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than \" + schema.maximum,\n      });\n    }\n  } else {\n    if(!(instance <= schema.maximum)){\n      result.addError({\n        name: 'maximum',\n        argument: schema.maximum,\n        message: \"must be less than or equal to \" + schema.maximum,\n      });\n    }\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMinimum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMinimum = function validateExclusiveMinimum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMinimum, which is handled by the \"minimum\" keyword.\n  if(typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance > schema.exclusiveMinimum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMinimum',\n      argument: schema.exclusiveMinimum,\n      message: \"must be strictly greater than \" + schema.exclusiveMinimum,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates the number form of exclusiveMaximum when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.exclusiveMaximum = function validateExclusiveMaximum (instance, schema, options, ctx) {\n  // Support the boolean form of exclusiveMaximum, which is handled by the \"maximum\" keyword.\n  if(typeof schema.exclusiveMaximum === 'boolean') return;\n  if (!this.types.number(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var valid = instance < schema.exclusiveMaximum;\n  if (!valid) {\n    result.addError({\n      name: 'exclusiveMaximum',\n      argument: schema.exclusiveMaximum,\n      message: \"must be strictly less than \" + schema.exclusiveMaximum,\n    });\n  }\n  return result;\n};\n\n/**\n * Perform validation for multipleOf and divisibleBy, which are essentially the same.\n * @param instance\n * @param schema\n * @param validationType\n * @param errorMessage\n * @returns {String|null}\n */\nvar validateMultipleOfOrDivisbleBy = function validateMultipleOfOrDivisbleBy (instance, schema, options, ctx, validationType, errorMessage) {\n  if (!this.types.number(instance)) return;\n\n  var validationArgument = schema[validationType];\n  if (validationArgument == 0) {\n    throw new SchemaError(validationType + \" cannot be zero\");\n  }\n\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  var instanceDecimals = helpers.getDecimalPlaces(instance);\n  var divisorDecimals = helpers.getDecimalPlaces(validationArgument);\n\n  var maxDecimals = Math.max(instanceDecimals , divisorDecimals);\n  var multiplier = Math.pow(10, maxDecimals);\n\n  if (Math.round(instance * multiplier) % Math.round(validationArgument * multiplier) !== 0) {\n    result.addError({\n      name: validationType,\n      argument:  validationArgument,\n      message: errorMessage + JSON.stringify(validationArgument),\n    });\n  }\n\n  return result;\n};\n\n/**\n * Validates divisibleBy when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.multipleOf = function validateMultipleOf (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"multipleOf\", \"is not a multiple of (divisible by) \");\n};\n\n/**\n * Validates multipleOf when the type of the instance value is a number.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.divisibleBy = function validateDivisibleBy (instance, schema, options, ctx) {\n  return validateMultipleOfOrDivisbleBy.call(this, instance, schema, options, ctx, \"divisibleBy\", \"is not divisible by (multiple of) \");\n};\n\n/**\n * Validates whether the instance value is present.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.required = function validateRequired (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (instance === undefined && schema.required === true) {\n    // A boolean form is implemented for reverse-compatibility with schemas written against older drafts\n    result.addError({\n      name: 'required',\n      message: \"is required\",\n    });\n  } else if (this.types.object(instance) && Array.isArray(schema.required)) {\n    schema.required.forEach(function(n){\n      if(getEnumerableProperty(instance, n)===undefined){\n        result.addError({\n          name: 'required',\n          argument: n,\n          message: \"requires property \" + JSON.stringify(n),\n        });\n      }\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value matches the regular expression, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.pattern = function validatePattern (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var pattern = schema.pattern;\n  try {\n    var regexp = new RegExp(pattern, 'u');\n  } catch(_e) {\n    // In the event the stricter handling causes an error, fall back on the forgiving handling\n    // DEPRECATED\n    regexp = new RegExp(pattern);\n  }\n  if (!instance.match(regexp)) {\n    result.addError({\n      name: 'pattern',\n      argument: schema.pattern,\n      message: \"does not match pattern \" + JSON.stringify(schema.pattern.toString()),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is of a certain defined format or a custom\n * format.\n * The following formats are supported for string types:\n *   - date-time\n *   - date\n *   - time\n *   - ip-address\n *   - ipv6\n *   - uri\n *   - color\n *   - host-name\n *   - alpha\n *   - alpha-numeric\n *   - utc-millisec\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {String|null}\n */\nvalidators.format = function validateFormat (instance, schema, options, ctx) {\n  if (instance===undefined) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!result.disableFormat && !helpers.isFormat(instance, schema.format, this)) {\n    result.addError({\n      name: 'format',\n      argument: schema.format,\n      message: \"does not conform to the \" + JSON.stringify(schema.format) + \" format\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at least of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minLength = function validateMinLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length >= schema.minLength)) {\n    result.addError({\n      name: 'minLength',\n      argument: schema.minLength,\n      message: \"does not meet minimum length of \" + schema.minLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is at most of a certain length, when the instance value is a string.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxLength = function validateMaxLength (instance, schema, options, ctx) {\n  if (!this.types.string(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  // TODO if this was already computed in \"minLength\", use that value instead of re-computing\n  var hsp = instance.match(/[\\uDC00-\\uDFFF]/g);\n  var length = instance.length - (hsp ? hsp.length : 0);\n  if (!(length <= schema.maxLength)) {\n    result.addError({\n      name: 'maxLength',\n      argument: schema.maxLength,\n      message: \"does not meet maximum length of \" + schema.maxLength,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains at least a minimum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.minItems = function validateMinItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length >= schema.minItems)) {\n    result.addError({\n      name: 'minItems',\n      argument: schema.minItems,\n      message: \"does not meet minimum length of \" + schema.minItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether instance contains no more than a maximum number of items, when the instance is an Array.\n * @param instance\n * @param schema\n * @return {String|null}\n */\nvalidators.maxItems = function validateMaxItems (instance, schema, options, ctx) {\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!(instance.length <= schema.maxItems)) {\n    result.addError({\n      name: 'maxItems',\n      argument: schema.maxItems,\n      message: \"does not meet maximum length of \" + schema.maxItems,\n    });\n  }\n  return result;\n};\n\n/**\n * Deep compares arrays for duplicates\n * @param v\n * @param i\n * @param a\n * @private\n * @return {boolean}\n */\nfunction testArrays (v, i, a) {\n  var j, len = a.length;\n  for (j = i + 1, len; j < len; j++) {\n    if (helpers.deepCompareStrict(v, a[j])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Validates whether there are no duplicates, when the instance is an Array.\n * @param instance\n * @return {String|null}\n */\nvalidators.uniqueItems = function validateUniqueItems (instance, schema, options, ctx) {\n  if (schema.uniqueItems!==true) return;\n  if (!this.types.array(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!instance.every(testArrays)) {\n    result.addError({\n      name: 'uniqueItems',\n      message: \"contains duplicate item\",\n    });\n  }\n  return result;\n};\n\n/**\n * Validate for the presence of dependency properties, if the instance is an object.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.dependencies = function validateDependencies (instance, schema, options, ctx) {\n  if (!this.types.object(instance)) return;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  for (var property in schema.dependencies) {\n    if (instance[property] === undefined) {\n      continue;\n    }\n    var dep = schema.dependencies[property];\n    var childContext = ctx.makeChild(dep, property);\n    if (typeof dep == 'string') {\n      dep = [dep];\n    }\n    if (Array.isArray(dep)) {\n      dep.forEach(function (prop) {\n        if (instance[prop] === undefined) {\n          result.addError({\n            // FIXME there's two different \"dependencies\" errors here with slightly different outputs\n            // Can we make these the same? Or should we create different error types?\n            name: 'dependencies',\n            argument: childContext.propertyPath,\n            message: \"property \" + prop + \" not found, required by \" + childContext.propertyPath,\n          });\n        }\n      });\n    } else {\n      var res = this.validateSchema(instance, dep, options, childContext);\n      if(result.instance !== res.instance) result.instance = res.instance;\n      if (res && res.errors.length) {\n        result.addError({\n          name: 'dependencies',\n          argument: childContext.propertyPath,\n          message: \"does not meet dependency required by \" + childContext.propertyPath,\n        });\n        result.importErrors(res);\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance value is one of the enumerated values.\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['enum'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  if (!Array.isArray(schema['enum'])) {\n    throw new SchemaError(\"enum expects an array\", schema);\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!schema['enum'].some(helpers.deepCompareStrict.bind(null, instance))) {\n    result.addError({\n      name: 'enum',\n      argument: schema['enum'],\n      message: \"is not one of enum values: \" + schema['enum'].map(String).join(','),\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance exactly matches a given value\n *\n * @param instance\n * @param schema\n * @return {ValidatorResult|null}\n */\nvalidators['const'] = function validateEnum (instance, schema, options, ctx) {\n  if (instance === undefined) {\n    return null;\n  }\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  if (!helpers.deepCompareStrict(schema['const'], instance)) {\n    result.addError({\n      name: 'const',\n      argument: schema['const'],\n      message: \"does not exactly match expected constant: \" + schema['const'],\n    });\n  }\n  return result;\n};\n\n/**\n * Validates whether the instance if of a prohibited type.\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @return {null|ValidatorResult}\n */\nvalidators.not = validators.disallow = function validateNot (instance, schema, options, ctx) {\n  var self = this;\n  if(instance===undefined) return null;\n  var result = new ValidatorResult(instance, schema, options, ctx);\n  var notTypes = schema.not || schema.disallow;\n  if(!notTypes) return null;\n  if(!Array.isArray(notTypes)) notTypes=[notTypes];\n  notTypes.forEach(function (type) {\n    if (self.testType(instance, schema, options, ctx, type)) {\n      var id = type && (type.$id || type.id);\n      var schemaId = id || type;\n      result.addError({\n        name: 'not',\n        argument: schemaId,\n        message: \"is of prohibited type \" + schemaId,\n      });\n    }\n  });\n  return result;\n};\n\nmodule.exports = attribute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY0ODEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLEtBQVc7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBb0Q7QUFDeEU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnB3ZC1udWkvLi9ub2RlX21vZHVsZXMvanNvbnNjaGVtYS9saWIvYXR0cmlidXRlLmpzPzY5OTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKiogQHR5cGUgVmFsaWRhdG9yUmVzdWx0ICovXG52YXIgVmFsaWRhdG9yUmVzdWx0ID0gaGVscGVycy5WYWxpZGF0b3JSZXN1bHQ7XG4vKiogQHR5cGUgU2NoZW1hRXJyb3IgKi9cbnZhciBTY2hlbWFFcnJvciA9IGhlbHBlcnMuU2NoZW1hRXJyb3I7XG5cbnZhciBhdHRyaWJ1dGUgPSB7fTtcblxuYXR0cmlidXRlLmlnbm9yZVByb3BlcnRpZXMgPSB7XG4gIC8vIGluZm9ybWF0aXZlIHByb3BlcnRpZXNcbiAgJ2lkJzogdHJ1ZSxcbiAgJ2RlZmF1bHQnOiB0cnVlLFxuICAnZGVzY3JpcHRpb24nOiB0cnVlLFxuICAndGl0bGUnOiB0cnVlLFxuICAvLyBhcmd1bWVudHMgdG8gb3RoZXIgcHJvcGVydGllc1xuICAnYWRkaXRpb25hbEl0ZW1zJzogdHJ1ZSxcbiAgJ3RoZW4nOiB0cnVlLFxuICAnZWxzZSc6IHRydWUsXG4gIC8vIHNwZWNpYWwtaGFuZGxlZCBwcm9wZXJ0aWVzXG4gICckc2NoZW1hJzogdHJ1ZSxcbiAgJyRyZWYnOiB0cnVlLFxuICAnZXh0ZW5kcyc6IHRydWUsXG59O1xuXG4vKipcbiAqIEBuYW1lIHZhbGlkYXRvcnNcbiAqL1xudmFyIHZhbGlkYXRvcnMgPSBhdHRyaWJ1dGUudmFsaWRhdG9ycyA9IHt9O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBpZiBvZiBhIGNlcnRhaW4gdHlwZVxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7VmFsaWRhdG9yUmVzdWx0fG51bGx9XG4gKi9cbnZhbGlkYXRvcnMudHlwZSA9IGZ1bmN0aW9uIHZhbGlkYXRlVHlwZSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIC8vIElnbm9yZSB1bmRlZmluZWQgaW5zdGFuY2VzXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHR5cGVzID0gQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkgPyBzY2hlbWEudHlwZSA6IFtzY2hlbWEudHlwZV07XG4gIGlmICghdHlwZXMuc29tZSh0aGlzLnRlc3RUeXBlLmJpbmQodGhpcywgaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSkpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVzLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgaWYoIXYpIHJldHVybjtcbiAgICAgIHZhciBpZCA9IHYuJGlkIHx8IHYuaWQ7XG4gICAgICByZXR1cm4gaWQgPyAoJzwnICsgaWQgKyAnPicpIDogKHYrJycpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAndHlwZScsXG4gICAgICBhcmd1bWVudDogbGlzdCxcbiAgICAgIG1lc3NhZ2U6IFwiaXMgbm90IG9mIGEgdHlwZShzKSBcIiArIGxpc3QsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmZ1bmN0aW9uIHRlc3RTY2hlbWFOb1Rocm93KGluc3RhbmNlLCBvcHRpb25zLCBjdHgsIGNhbGxiYWNrLCBzY2hlbWEpe1xuICB2YXIgdGhyb3dFcnJvciA9IG9wdGlvbnMudGhyb3dFcnJvcjtcbiAgdmFyIHRocm93QWxsID0gb3B0aW9ucy50aHJvd0FsbDtcbiAgb3B0aW9ucy50aHJvd0Vycm9yID0gZmFsc2U7XG4gIG9wdGlvbnMudGhyb3dBbGwgPSBmYWxzZTtcbiAgdmFyIHJlcyA9IHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgb3B0aW9ucy50aHJvd0Vycm9yID0gdGhyb3dFcnJvcjtcbiAgb3B0aW9ucy50aHJvd0FsbCA9IHRocm93QWxsO1xuXG4gIGlmICghcmVzLnZhbGlkICYmIGNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBjYWxsYmFjayhyZXMpO1xuICB9XG4gIHJldHVybiByZXMudmFsaWQ7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIG1hdGNoZXMgc29tZSBvZiB0aGUgZ2l2ZW4gc2NoZW1hc1xuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7VmFsaWRhdG9yUmVzdWx0fG51bGx9XG4gKi9cbnZhbGlkYXRvcnMuYW55T2YgPSBmdW5jdGlvbiB2YWxpZGF0ZUFueU9mIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgLy8gSWdub3JlIHVuZGVmaW5lZCBpbnN0YW5jZXNcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgaW5uZXIgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKXtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJhbnlPZiBtdXN0IGJlIGFuIGFycmF5XCIpO1xuICB9XG4gIGlmICghc2NoZW1hLmFueU9mLnNvbWUoXG4gICAgdGVzdFNjaGVtYU5vVGhyb3cuYmluZChcbiAgICAgIHRoaXMsIGluc3RhbmNlLCBvcHRpb25zLCBjdHgsIGZ1bmN0aW9uKHJlcyl7aW5uZXIuaW1wb3J0RXJyb3JzKHJlcyk7fVxuICAgICkpKSB7XG4gICAgdmFyIGxpc3QgPSBzY2hlbWEuYW55T2YubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICB2YXIgaWQgPSB2LiRpZCB8fCB2LmlkO1xuICAgICAgaWYoaWQpIHJldHVybiAnPCcgKyBpZCArICc+JztcbiAgICAgIHJldHVybih2LnRpdGxlICYmIEpTT04uc3RyaW5naWZ5KHYudGl0bGUpKSB8fCAodlsnJHJlZiddICYmICgnPCcgKyB2WyckcmVmJ10gKyAnPicpKSB8fCAnW3N1YnNjaGVtYSAnK2krJ10nO1xuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLm5lc3RlZEVycm9ycykge1xuICAgICAgcmVzdWx0LmltcG9ydEVycm9ycyhpbm5lcik7XG4gICAgfVxuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnYW55T2YnLFxuICAgICAgYXJndW1lbnQ6IGxpc3QsXG4gICAgICBtZXNzYWdlOiBcImlzIG5vdCBhbnkgb2YgXCIgKyBsaXN0LmpvaW4oJywnKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgbWF0Y2hlcyBldmVyeSBnaXZlbiBzY2hlbWFcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLmFsbE9mID0gZnVuY3Rpb24gdmFsaWRhdGVBbGxPZiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIC8vIElnbm9yZSB1bmRlZmluZWQgaW5zdGFuY2VzXG4gIGlmIChpbnN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpe1xuICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcImFsbE9mIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzY2hlbWEuYWxsT2YuZm9yRWFjaChmdW5jdGlvbih2LCBpKXtcbiAgICB2YXIgdmFsaWQgPSBzZWxmLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlLCB2LCBvcHRpb25zLCBjdHgpO1xuICAgIGlmKCF2YWxpZC52YWxpZCl7XG4gICAgICB2YXIgaWQgPSB2LiRpZCB8fCB2LmlkO1xuICAgICAgdmFyIG1zZyA9IGlkIHx8ICh2LnRpdGxlICYmIEpTT04uc3RyaW5naWZ5KHYudGl0bGUpKSB8fCAodlsnJHJlZiddICYmICgnPCcgKyB2WyckcmVmJ10gKyAnPicpKSB8fCAnW3N1YnNjaGVtYSAnK2krJ10nO1xuICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgbmFtZTogJ2FsbE9mJyxcbiAgICAgICAgYXJndW1lbnQ6IHsgaWQ6IG1zZywgbGVuZ3RoOiB2YWxpZC5lcnJvcnMubGVuZ3RoLCB2YWxpZDogdmFsaWQgfSxcbiAgICAgICAgbWVzc2FnZTogJ2RvZXMgbm90IG1hdGNoIGFsbE9mIHNjaGVtYSAnICsgbXNnICsgJyB3aXRoICcgKyB2YWxpZC5lcnJvcnMubGVuZ3RoICsgJyBlcnJvcltzXTonLFxuICAgICAgfSk7XG4gICAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHZhbGlkKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgbWF0Y2hlcyBleGFjdGx5IG9uZSBvZiB0aGUgZ2l2ZW4gc2NoZW1hc1xuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMub25lT2YgPSBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgLy8gSWdub3JlIHVuZGVmaW5lZCBpbnN0YW5jZXNcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSl7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKFwib25lT2YgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgaW5uZXIgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBjb3VudCA9IHNjaGVtYS5vbmVPZi5maWx0ZXIoXG4gICAgdGVzdFNjaGVtYU5vVGhyb3cuYmluZChcbiAgICAgIHRoaXMsIGluc3RhbmNlLCBvcHRpb25zLCBjdHgsIGZ1bmN0aW9uKHJlcykge2lubmVyLmltcG9ydEVycm9ycyhyZXMpO31cbiAgICApICkubGVuZ3RoO1xuICB2YXIgbGlzdCA9IHNjaGVtYS5vbmVPZi5tYXAoZnVuY3Rpb24gKHYsIGkpIHtcbiAgICB2YXIgaWQgPSB2LiRpZCB8fCB2LmlkO1xuICAgIHJldHVybiBpZCB8fCAodi50aXRsZSAmJiBKU09OLnN0cmluZ2lmeSh2LnRpdGxlKSkgfHwgKHZbJyRyZWYnXSAmJiAoJzwnICsgdlsnJHJlZiddICsgJz4nKSkgfHwgJ1tzdWJzY2hlbWEgJytpKyddJztcbiAgfSk7XG4gIGlmIChjb3VudCE9PTEpIHtcbiAgICBpZiAob3B0aW9ucy5uZXN0ZWRFcnJvcnMpIHtcbiAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMoaW5uZXIpO1xuICAgIH1cbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ29uZU9mJyxcbiAgICAgIGFyZ3VtZW50OiBsaXN0LFxuICAgICAgbWVzc2FnZTogXCJpcyBub3QgZXhhY3RseSBvbmUgZnJvbSBcIiArIGxpc3Quam9pbignLCcpLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBcInRoZW5cIiBvciBcImVsc2VcIiBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdCBvZiB2YWxpZGF0aW5nIFwiaWZcIlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMuaWYgPSBmdW5jdGlvbiB2YWxpZGF0ZUlmIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgLy8gSWdub3JlIHVuZGVmaW5lZCBpbnN0YW5jZXNcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuICBpZiAoIWhlbHBlcnMuaXNTY2hlbWEoc2NoZW1hLmlmKSkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcImlmXCIga2V5d29yZCB0byBiZSBhIHNjaGVtYScpO1xuICB2YXIgaWZWYWxpZCA9IHRlc3RTY2hlbWFOb1Rocm93LmNhbGwodGhpcywgaW5zdGFuY2UsIG9wdGlvbnMsIGN0eCwgbnVsbCwgc2NoZW1hLmlmKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHJlcztcbiAgaWYoaWZWYWxpZCl7XG4gICAgaWYgKHNjaGVtYS50aGVuID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAoIWhlbHBlcnMuaXNTY2hlbWEoc2NoZW1hLnRoZW4pKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwidGhlblwiIGtleXdvcmQgdG8gYmUgYSBzY2hlbWEnKTtcbiAgICByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlLCBzY2hlbWEudGhlbiwgb3B0aW9ucywgY3R4Lm1ha2VDaGlsZChzY2hlbWEudGhlbikpO1xuICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgfWVsc2V7XG4gICAgaWYgKHNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAoIWhlbHBlcnMuaXNTY2hlbWEoc2NoZW1hLmVsc2UpKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFwiZWxzZVwiIGtleXdvcmQgdG8gYmUgYSBzY2hlbWEnKTtcbiAgICByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlLCBzY2hlbWEuZWxzZSwgb3B0aW9ucywgY3R4Lm1ha2VDaGlsZChzY2hlbWEuZWxzZSkpO1xuICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZVByb3BlcnR5KG9iamVjdCwga2V5KXtcbiAgLy8gRGV0ZXJtaW5lIGlmIGBrZXlgIHNob3dzIHVwIGluIGBmb3IodmFyIGtleSBpbiBvYmplY3QpYFxuICAvLyBGaXJzdCB0ZXN0IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsIGFzIGFuIG9wdGltaXphdGlvbjogdGhhdCBndWFyYW50ZWVzIGl0IGRvZXNcbiAgaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSByZXR1cm4gb2JqZWN0W2tleV07XG4gIC8vIFRlc3QgYGtleSBpbiBvYmplY3RgIGFzIGFuIG9wdGltaXphdGlvbjsgZmFsc2UgbWVhbnMgaXQgd29uJ3RcbiAgaWYoIShrZXkgaW4gb2JqZWN0KSkgcmV0dXJuO1xuICB3aGlsZSggKG9iamVjdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpKSApe1xuICAgIGlmKE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwga2V5KSkgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHByb3BlcnR5TmFtZXNcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5wcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eU5hbWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYoIXRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgc3Vic2NoZW1hID0gc2NoZW1hLnByb3BlcnR5TmFtZXMhPT11bmRlZmluZWQgPyBzY2hlbWEucHJvcGVydHlOYW1lcyA6IHt9O1xuICBpZighaGVscGVycy5pc1NjaGVtYShzdWJzY2hlbWEpKSB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoJ0V4cGVjdGVkIFwicHJvcGVydHlOYW1lc1wiIHRvIGJlIGEgc2NoZW1hIChvYmplY3Qgb3IgYm9vbGVhbiknKTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBpbnN0YW5jZSkge1xuICAgIGlmKGdldEVudW1lcmFibGVQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHkpICE9PSB1bmRlZmluZWQpe1xuICAgICAgdmFyIHJlcyA9IHRoaXMudmFsaWRhdGVTY2hlbWEocHJvcGVydHksIHN1YnNjaGVtYSwgb3B0aW9ucywgY3R4Lm1ha2VDaGlsZChzdWJzY2hlbWEpKTtcbiAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgcHJvcGVydGllc1xuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7U3RyaW5nfG51bGx8VmFsaWRhdG9yUmVzdWx0fVxuICovXG52YWxpZGF0b3JzLnByb3BlcnRpZXMgPSBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZighdGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXMgfHwge307XG4gIGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgc3Vic2NoZW1hID0gcHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgaWYoc3Vic2NoZW1hPT09dW5kZWZpbmVkKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1lbHNlIGlmKHN1YnNjaGVtYT09PW51bGwpe1xuICAgICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKCdVbmV4cGVjdGVkIG51bGwsIGV4cGVjdGVkIHNjaGVtYSBpbiBcInByb3BlcnRpZXNcIicpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zLnByZVZhbGlkYXRlUHJvcGVydHkoaW5zdGFuY2UsIHByb3BlcnR5LCBzdWJzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgfVxuICAgIHZhciBwcm9wID0gZ2V0RW51bWVyYWJsZVByb3BlcnR5KGluc3RhbmNlLCBwcm9wZXJ0eSk7XG4gICAgdmFyIHJlcyA9IHRoaXMudmFsaWRhdGVTY2hlbWEocHJvcCwgc3Vic2NoZW1hLCBvcHRpb25zLCBjdHgubWFrZUNoaWxkKHN1YnNjaGVtYSwgcHJvcGVydHkpKTtcbiAgICBpZihyZXMuaW5zdGFuY2UgIT09IHJlc3VsdC5pbnN0YW5jZVtwcm9wZXJ0eV0pIHJlc3VsdC5pbnN0YW5jZVtwcm9wZXJ0eV0gPSByZXMuaW5zdGFuY2U7XG4gICAgcmVzdWx0LmltcG9ydEVycm9ycyhyZXMpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFRlc3QgYSBzcGVjaWZpYyBwcm9wZXJ0eSB3aXRoaW4gaW4gaW5zdGFuY2UgYWdhaW5zdCB0aGUgYWRkaXRpb25hbFByb3BlcnRpZXMgc2NoZW1hIGF0dHJpYnV0ZVxuICogVGhpcyBpZ25vcmVzIHByb3BlcnRpZXMgd2l0aCBkZWZpbml0aW9ucyBpbiB0aGUgcHJvcGVydGllcyBzY2hlbWEgYXR0cmlidXRlLCBidXQgbm8gb3RoZXIgYXR0cmlidXRlcy5cbiAqIElmIHRvbyBtYW55IG1vcmUgdHlwZXMgb2YgcHJvcGVydHktZXhpc3RlbmNlIHRlc3RzIHBvcCB1cCB0aGV5IG1heSBuZWVkIHRoZWlyIG93biBjbGFzcyBvZiB0ZXN0cyAobGlrZSBgdHlwZWAgaGFzKVxuICogQHByaXZhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHRlc3RBZGRpdGlvbmFsUHJvcGVydHkgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgcHJvcGVydHksIHJlc3VsdCkge1xuICBpZighdGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpKSByZXR1cm47XG4gIGlmIChzY2hlbWEucHJvcGVydGllcyAmJiBzY2hlbWEucHJvcGVydGllc1twcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAgICAgYXJndW1lbnQ6IHByb3BlcnR5LFxuICAgICAgbWVzc2FnZTogXCJpcyBub3QgYWxsb3dlZCB0byBoYXZlIHRoZSBhZGRpdGlvbmFsIHByb3BlcnR5IFwiICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydHkpLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyB8fCB7fTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmVWYWxpZGF0ZVByb3BlcnR5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMucHJlVmFsaWRhdGVQcm9wZXJ0eShpbnN0YW5jZSwgcHJvcGVydHksIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBvcHRpb25zLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB0aGlzLnZhbGlkYXRlU2NoZW1hKGluc3RhbmNlW3Byb3BlcnR5XSwgYWRkaXRpb25hbFByb3BlcnRpZXMsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoYWRkaXRpb25hbFByb3BlcnRpZXMsIHByb3BlcnR5KSk7XG4gICAgaWYocmVzLmluc3RhbmNlICE9PSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldKSByZXN1bHQuaW5zdGFuY2VbcHJvcGVydHldID0gcmVzLmluc3RhbmNlO1xuICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBwYXR0ZXJuUHJvcGVydGllc1xuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIGN0eFxuICogQHJldHVybiB7U3RyaW5nfG51bGx8VmFsaWRhdG9yUmVzdWx0fVxuICovXG52YWxpZGF0b3JzLnBhdHRlcm5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmKCF0aGlzLnR5cGVzLm9iamVjdChpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHBhdHRlcm5Qcm9wZXJ0aWVzID0gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzIHx8IHt9O1xuXG4gIGZvciAodmFyIHByb3BlcnR5IGluIGluc3RhbmNlKSB7XG4gICAgdmFyIHRlc3QgPSB0cnVlO1xuICAgIGZvciAodmFyIHBhdHRlcm4gaW4gcGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBzdWJzY2hlbWEgPSBwYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuXTtcbiAgICAgIGlmKHN1YnNjaGVtYT09PXVuZGVmaW5lZCl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfWVsc2UgaWYoc3Vic2NoZW1hPT09bnVsbCl7XG4gICAgICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcignVW5leHBlY3RlZCBudWxsLCBleHBlY3RlZCBzY2hlbWEgaW4gXCJwYXR0ZXJuUHJvcGVydGllc1wiJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCAndScpO1xuICAgICAgfSBjYXRjaChfZSkge1xuICAgICAgICAvLyBJbiB0aGUgZXZlbnQgdGhlIHN0cmljdGVyIGhhbmRsaW5nIGNhdXNlcyBhbiBlcnJvciwgZmFsbCBiYWNrIG9uIHRoZSBmb3JnaXZpbmcgaGFuZGxpbmdcbiAgICAgICAgLy8gREVQUkVDQVRFRFxuICAgICAgICByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWdleHAudGVzdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0ZXN0ID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wcmVWYWxpZGF0ZVByb3BlcnR5ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5wcmVWYWxpZGF0ZVByb3BlcnR5KGluc3RhbmNlLCBwcm9wZXJ0eSwgc3Vic2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZVtwcm9wZXJ0eV0sIHN1YnNjaGVtYSwgb3B0aW9ucywgY3R4Lm1ha2VDaGlsZChzdWJzY2hlbWEsIHByb3BlcnR5KSk7XG4gICAgICBpZihyZXMuaW5zdGFuY2UgIT09IHJlc3VsdC5pbnN0YW5jZVtwcm9wZXJ0eV0pIHJlc3VsdC5pbnN0YW5jZVtwcm9wZXJ0eV0gPSByZXMuaW5zdGFuY2U7XG4gICAgICByZXN1bHQuaW1wb3J0RXJyb3JzKHJlcyk7XG4gICAgfVxuICAgIGlmICh0ZXN0KSB7XG4gICAgICB0ZXN0QWRkaXRpb25hbFByb3BlcnR5LmNhbGwodGhpcywgaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4LCBwcm9wZXJ0eSwgcmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWRkaXRpb25hbFByb3BlcnRpZXNcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5hZGRpdGlvbmFsUHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbFByb3BlcnRpZXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZighdGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpKSByZXR1cm47XG4gIC8vIGlmIHBhdHRlcm5Qcm9wZXJ0aWVzIGlzIGRlZmluZWQgdGhlbiB3ZSdsbCB0ZXN0IHdoZW4gdGhhdCBvbmUgaXMgY2FsbGVkIGluc3RlYWRcbiAgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGZvciAodmFyIHByb3BlcnR5IGluIGluc3RhbmNlKSB7XG4gICAgdGVzdEFkZGl0aW9uYWxQcm9wZXJ0eS5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgcHJvcGVydHksIHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlIGluc3RhbmNlIHZhbHVlIGlzIGF0IGxlYXN0IG9mIGEgY2VydGFpbiBsZW5ndGgsIHdoZW4gdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5taW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gdmFsaWRhdGVNaW5Qcm9wZXJ0aWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCF0aGlzLnR5cGVzLm9iamVjdChpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZSk7XG4gIGlmICghKGtleXMubGVuZ3RoID49IHNjaGVtYS5taW5Qcm9wZXJ0aWVzKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWluUHJvcGVydGllcycsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLm1pblByb3BlcnRpZXMsXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1lZXQgbWluaW11bSBwcm9wZXJ0eSBsZW5ndGggb2YgXCIgKyBzY2hlbWEubWluUHJvcGVydGllcyxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYXQgbW9zdCBvZiBhIGNlcnRhaW4gbGVuZ3RoLCB3aGVuIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWF4UHJvcGVydGllcyA9IGZ1bmN0aW9uIHZhbGlkYXRlTWF4UHJvcGVydGllcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghdGhpcy50eXBlcy5vYmplY3QoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoaW5zdGFuY2UpO1xuICBpZiAoIShrZXlzLmxlbmd0aCA8PSBzY2hlbWEubWF4UHJvcGVydGllcykpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ21heFByb3BlcnRpZXMnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5tYXhQcm9wZXJ0aWVzLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1heGltdW0gcHJvcGVydHkgbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1heFByb3BlcnRpZXMsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIGl0ZW1zIHdoZW4gaW5zdGFuY2UgaXMgYW4gYXJyYXlcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfFZhbGlkYXRvclJlc3VsdH1cbiAqL1xudmFsaWRhdG9ycy5pdGVtcyA9IGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghdGhpcy50eXBlcy5hcnJheShpbnN0YW5jZSkpIHJldHVybjtcbiAgaWYgKCFzY2hlbWEuaXRlbXMpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaW5zdGFuY2UuZXZlcnkoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgdmFyIGl0ZW1zID0gQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpID8gKHNjaGVtYS5pdGVtc1tpXSB8fCBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zKSA6IHNjaGVtYS5pdGVtcztcbiAgICBpZiAoaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgIG5hbWU6ICdpdGVtcycsXG4gICAgICAgIG1lc3NhZ2U6IFwiYWRkaXRpb25hbEl0ZW1zIG5vdCBwZXJtaXR0ZWRcIixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcmVzID0gc2VsZi52YWxpZGF0ZVNjaGVtYSh2YWx1ZSwgaXRlbXMsIG9wdGlvbnMsIGN0eC5tYWtlQ2hpbGQoaXRlbXMsIGkpKTtcbiAgICBpZihyZXMuaW5zdGFuY2UgIT09IHJlc3VsdC5pbnN0YW5jZVtpXSkgcmVzdWx0Lmluc3RhbmNlW2ldID0gcmVzLmluc3RhbmNlO1xuICAgIHJlc3VsdC5pbXBvcnRFcnJvcnMocmVzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBtaW5pbXVtIGFuZCBleGNsdXNpdmVNaW5pbXVtIHdoZW4gdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5taW5pbXVtID0gZnVuY3Rpb24gdmFsaWRhdGVNaW5pbXVtIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCF0aGlzLnR5cGVzLm51bWJlcihpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtICYmIHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtID09PSB0cnVlKSB7XG4gICAgaWYoIShpbnN0YW5jZSA+IHNjaGVtYS5taW5pbXVtKSl7XG4gICAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgICBuYW1lOiAnbWluaW11bScsXG4gICAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWluaW11bSxcbiAgICAgICAgbWVzc2FnZTogXCJtdXN0IGJlIGdyZWF0ZXIgdGhhbiBcIiArIHNjaGVtYS5taW5pbXVtLFxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmKCEoaW5zdGFuY2UgPj0gc2NoZW1hLm1pbmltdW0pKXtcbiAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgIG5hbWU6ICdtaW5pbXVtJyxcbiAgICAgICAgYXJndW1lbnQ6IHNjaGVtYS5taW5pbXVtLFxuICAgICAgICBtZXNzYWdlOiBcIm11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiICsgc2NoZW1hLm1pbmltdW0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIG1heGltdW0gYW5kIGV4Y2x1c2l2ZU1heGltdW0gd2hlbiB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLm1heGltdW0gPSBmdW5jdGlvbiB2YWxpZGF0ZU1heGltdW0gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIXRoaXMudHlwZXMubnVtYmVyKGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gJiYgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUpIHtcbiAgICBpZighKGluc3RhbmNlIDwgc2NoZW1hLm1heGltdW0pKXtcbiAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgIG5hbWU6ICdtYXhpbXVtJyxcbiAgICAgICAgYXJndW1lbnQ6IHNjaGVtYS5tYXhpbXVtLFxuICAgICAgICBtZXNzYWdlOiBcIm11c3QgYmUgbGVzcyB0aGFuIFwiICsgc2NoZW1hLm1heGltdW0sXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYoIShpbnN0YW5jZSA8PSBzY2hlbWEubWF4aW11bSkpe1xuICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgbmFtZTogJ21heGltdW0nLFxuICAgICAgICBhcmd1bWVudDogc2NoZW1hLm1heGltdW0sXG4gICAgICAgIG1lc3NhZ2U6IFwibXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gXCIgKyBzY2hlbWEubWF4aW11bSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIG51bWJlciBmb3JtIG9mIGV4Y2x1c2l2ZU1pbmltdW0gd2hlbiB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLmV4Y2x1c2l2ZU1pbmltdW0gPSBmdW5jdGlvbiB2YWxpZGF0ZUV4Y2x1c2l2ZU1pbmltdW0gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICAvLyBTdXBwb3J0IHRoZSBib29sZWFuIGZvcm0gb2YgZXhjbHVzaXZlTWluaW11bSwgd2hpY2ggaXMgaGFuZGxlZCBieSB0aGUgXCJtaW5pbXVtXCIga2V5d29yZC5cbiAgaWYodHlwZW9mIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtID09PSAnYm9vbGVhbicpIHJldHVybjtcbiAgaWYgKCF0aGlzLnR5cGVzLm51bWJlcihpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIHZhbGlkID0gaW5zdGFuY2UgPiBzY2hlbWEuZXhjbHVzaXZlTWluaW11bTtcbiAgaWYgKCF2YWxpZCkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnZXhjbHVzaXZlTWluaW11bScsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0sXG4gICAgICBtZXNzYWdlOiBcIm11c3QgYmUgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFwiICsgc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0sXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoZSBudW1iZXIgZm9ybSBvZiBleGNsdXNpdmVNYXhpbXVtIHdoZW4gdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy5leGNsdXNpdmVNYXhpbXVtID0gZnVuY3Rpb24gdmFsaWRhdGVFeGNsdXNpdmVNYXhpbXVtIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgLy8gU3VwcG9ydCB0aGUgYm9vbGVhbiBmb3JtIG9mIGV4Y2x1c2l2ZU1heGltdW0sIHdoaWNoIGlzIGhhbmRsZWQgYnkgdGhlIFwibWF4aW11bVwiIGtleXdvcmQuXG4gIGlmKHR5cGVvZiBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gJ2Jvb2xlYW4nKSByZXR1cm47XG4gIGlmICghdGhpcy50eXBlcy5udW1iZXIoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciB2YWxpZCA9IGluc3RhbmNlIDwgc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW07XG4gIGlmICghdmFsaWQpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2V4Y2x1c2l2ZU1heGltdW0nLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtLFxuICAgICAgbWVzc2FnZTogXCJtdXN0IGJlIHN0cmljdGx5IGxlc3MgdGhhbiBcIiArIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gdmFsaWRhdGlvbiBmb3IgbXVsdGlwbGVPZiBhbmQgZGl2aXNpYmxlQnksIHdoaWNoIGFyZSBlc3NlbnRpYWxseSB0aGUgc2FtZS5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIHZhbGlkYXRpb25UeXBlXG4gKiBAcGFyYW0gZXJyb3JNZXNzYWdlXG4gKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9XG4gKi9cbnZhciB2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkgPSBmdW5jdGlvbiB2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCwgdmFsaWRhdGlvblR5cGUsIGVycm9yTWVzc2FnZSkge1xuICBpZiAoIXRoaXMudHlwZXMubnVtYmVyKGluc3RhbmNlKSkgcmV0dXJuO1xuXG4gIHZhciB2YWxpZGF0aW9uQXJndW1lbnQgPSBzY2hlbWFbdmFsaWRhdGlvblR5cGVdO1xuICBpZiAodmFsaWRhdGlvbkFyZ3VtZW50ID09IDApIHtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IodmFsaWRhdGlvblR5cGUgKyBcIiBjYW5ub3QgYmUgemVyb1wiKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG5cbiAgdmFyIGluc3RhbmNlRGVjaW1hbHMgPSBoZWxwZXJzLmdldERlY2ltYWxQbGFjZXMoaW5zdGFuY2UpO1xuICB2YXIgZGl2aXNvckRlY2ltYWxzID0gaGVscGVycy5nZXREZWNpbWFsUGxhY2VzKHZhbGlkYXRpb25Bcmd1bWVudCk7XG5cbiAgdmFyIG1heERlY2ltYWxzID0gTWF0aC5tYXgoaW5zdGFuY2VEZWNpbWFscyAsIGRpdmlzb3JEZWNpbWFscyk7XG4gIHZhciBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIG1heERlY2ltYWxzKTtcblxuICBpZiAoTWF0aC5yb3VuZChpbnN0YW5jZSAqIG11bHRpcGxpZXIpICUgTWF0aC5yb3VuZCh2YWxpZGF0aW9uQXJndW1lbnQgKiBtdWx0aXBsaWVyKSAhPT0gMCkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiB2YWxpZGF0aW9uVHlwZSxcbiAgICAgIGFyZ3VtZW50OiAgdmFsaWRhdGlvbkFyZ3VtZW50LFxuICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlICsgSlNPTi5zdHJpbmdpZnkodmFsaWRhdGlvbkFyZ3VtZW50KSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBkaXZpc2libGVCeSB3aGVuIHRoZSB0eXBlIG9mIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubXVsdGlwbGVPZiA9IGZ1bmN0aW9uIHZhbGlkYXRlTXVsdGlwbGVPZiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIHJldHVybiB2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkuY2FsbCh0aGlzLCBpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgsIFwibXVsdGlwbGVPZlwiLCBcImlzIG5vdCBhIG11bHRpcGxlIG9mIChkaXZpc2libGUgYnkpIFwiKTtcbn07XG5cbi8qKlxuICogVmFsaWRhdGVzIG11bHRpcGxlT2Ygd2hlbiB0aGUgdHlwZSBvZiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLmRpdmlzaWJsZUJ5ID0gZnVuY3Rpb24gdmFsaWRhdGVEaXZpc2libGVCeSAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIHJldHVybiB2YWxpZGF0ZU11bHRpcGxlT2ZPckRpdmlzYmxlQnkuY2FsbCh0aGlzLCBpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgsIFwiZGl2aXNpYmxlQnlcIiwgXCJpcyBub3QgZGl2aXNpYmxlIGJ5IChtdWx0aXBsZSBvZikgXCIpO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgcHJlc2VudC5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMucmVxdWlyZWQgPSBmdW5jdGlvbiB2YWxpZGF0ZVJlcXVpcmVkIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQgJiYgc2NoZW1hLnJlcXVpcmVkID09PSB0cnVlKSB7XG4gICAgLy8gQSBib29sZWFuIGZvcm0gaXMgaW1wbGVtZW50ZWQgZm9yIHJldmVyc2UtY29tcGF0aWJpbGl0eSB3aXRoIHNjaGVtYXMgd3JpdHRlbiBhZ2FpbnN0IG9sZGVyIGRyYWZ0c1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAncmVxdWlyZWQnLFxuICAgICAgbWVzc2FnZTogXCJpcyByZXF1aXJlZFwiLFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMudHlwZXMub2JqZWN0KGluc3RhbmNlKSAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkpIHtcbiAgICBzY2hlbWEucmVxdWlyZWQuZm9yRWFjaChmdW5jdGlvbihuKXtcbiAgICAgIGlmKGdldEVudW1lcmFibGVQcm9wZXJ0eShpbnN0YW5jZSwgbik9PT11bmRlZmluZWQpe1xuICAgICAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgICAgIG5hbWU6ICdyZXF1aXJlZCcsXG4gICAgICAgICAgYXJndW1lbnQ6IG4sXG4gICAgICAgICAgbWVzc2FnZTogXCJyZXF1aXJlcyBwcm9wZXJ0eSBcIiArIEpTT04uc3RyaW5naWZ5KG4pLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgbWF0Y2hlcyB0aGUgcmVndWxhciBleHByZXNzaW9uLCB3aGVuIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMucGF0dGVybiA9IGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVybiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghdGhpcy50eXBlcy5zdHJpbmcoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIHZhciBwYXR0ZXJuID0gc2NoZW1hLnBhdHRlcm47XG4gIHRyeSB7XG4gICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ3UnKTtcbiAgfSBjYXRjaChfZSkge1xuICAgIC8vIEluIHRoZSBldmVudCB0aGUgc3RyaWN0ZXIgaGFuZGxpbmcgY2F1c2VzIGFuIGVycm9yLCBmYWxsIGJhY2sgb24gdGhlIGZvcmdpdmluZyBoYW5kbGluZ1xuICAgIC8vIERFUFJFQ0FURURcbiAgICByZWdleHAgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICB9XG4gIGlmICghaW5zdGFuY2UubWF0Y2gocmVnZXhwKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAncGF0dGVybicsXG4gICAgICBhcmd1bWVudDogc2NoZW1hLnBhdHRlcm4sXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1hdGNoIHBhdHRlcm4gXCIgKyBKU09OLnN0cmluZ2lmeShzY2hlbWEucGF0dGVybi50b1N0cmluZygpKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgb2YgYSBjZXJ0YWluIGRlZmluZWQgZm9ybWF0IG9yIGEgY3VzdG9tXG4gKiBmb3JtYXQuXG4gKiBUaGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBmb3Igc3RyaW5nIHR5cGVzOlxuICogICAtIGRhdGUtdGltZVxuICogICAtIGRhdGVcbiAqICAgLSB0aW1lXG4gKiAgIC0gaXAtYWRkcmVzc1xuICogICAtIGlwdjZcbiAqICAgLSB1cmlcbiAqICAgLSBjb2xvclxuICogICAtIGhvc3QtbmFtZVxuICogICAtIGFscGhhXG4gKiAgIC0gYWxwaGEtbnVtZXJpY1xuICogICAtIHV0Yy1taWxsaXNlY1xuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gc2NoZW1hXG4gKiBAcGFyYW0gW29wdGlvbnNdXG4gKiBAcGFyYW0gW2N0eF1cbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLmZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0IChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKGluc3RhbmNlPT09dW5kZWZpbmVkKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghcmVzdWx0LmRpc2FibGVGb3JtYXQgJiYgIWhlbHBlcnMuaXNGb3JtYXQoaW5zdGFuY2UsIHNjaGVtYS5mb3JtYXQsIHRoaXMpKSB7XG4gICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgIG5hbWU6ICdmb3JtYXQnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5mb3JtYXQsXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIFwiICsgSlNPTi5zdHJpbmdpZnkoc2NoZW1hLmZvcm1hdCkgKyBcIiBmb3JtYXRcIixcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYXQgbGVhc3Qgb2YgYSBjZXJ0YWluIGxlbmd0aCwgd2hlbiB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIHZhbGlkYXRlTWluTGVuZ3RoIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCF0aGlzLnR5cGVzLnN0cmluZyhpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgdmFyIGhzcCA9IGluc3RhbmNlLm1hdGNoKC9bXFx1REMwMC1cXHVERkZGXS9nKTtcbiAgdmFyIGxlbmd0aCA9IGluc3RhbmNlLmxlbmd0aCAtIChoc3AgPyBoc3AubGVuZ3RoIDogMCk7XG4gIGlmICghKGxlbmd0aCA+PSBzY2hlbWEubWluTGVuZ3RoKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWluTGVuZ3RoJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWluTGVuZ3RoLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1pbmltdW0gbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1pbkxlbmd0aCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgYXQgbW9zdCBvZiBhIGNlcnRhaW4gbGVuZ3RoLCB3aGVuIHRoZSBpbnN0YW5jZSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWF4TGVuZ3RoID0gZnVuY3Rpb24gdmFsaWRhdGVNYXhMZW5ndGggKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoIXRoaXMudHlwZXMuc3RyaW5nKGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICAvLyBUT0RPIGlmIHRoaXMgd2FzIGFscmVhZHkgY29tcHV0ZWQgaW4gXCJtaW5MZW5ndGhcIiwgdXNlIHRoYXQgdmFsdWUgaW5zdGVhZCBvZiByZS1jb21wdXRpbmdcbiAgdmFyIGhzcCA9IGluc3RhbmNlLm1hdGNoKC9bXFx1REMwMC1cXHVERkZGXS9nKTtcbiAgdmFyIGxlbmd0aCA9IGluc3RhbmNlLmxlbmd0aCAtIChoc3AgPyBoc3AubGVuZ3RoIDogMCk7XG4gIGlmICghKGxlbmd0aCA8PSBzY2hlbWEubWF4TGVuZ3RoKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWF4TGVuZ3RoJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWF4TGVuZ3RoLFxuICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IG1heGltdW0gbGVuZ3RoIG9mIFwiICsgc2NoZW1hLm1heExlbmd0aCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciBpbnN0YW5jZSBjb250YWlucyBhdCBsZWFzdCBhIG1pbmltdW0gbnVtYmVyIG9mIGl0ZW1zLCB3aGVuIHRoZSBpbnN0YW5jZSBpcyBhbiBBcnJheS5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHJldHVybiB7U3RyaW5nfG51bGx9XG4gKi9cbnZhbGlkYXRvcnMubWluSXRlbXMgPSBmdW5jdGlvbiB2YWxpZGF0ZU1pbkl0ZW1zIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCF0aGlzLnR5cGVzLmFycmF5KGluc3RhbmNlKSkgcmV0dXJuO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoIShpbnN0YW5jZS5sZW5ndGggPj0gc2NoZW1hLm1pbkl0ZW1zKSkge1xuICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICBuYW1lOiAnbWluSXRlbXMnLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYS5taW5JdGVtcyxcbiAgICAgIG1lc3NhZ2U6IFwiZG9lcyBub3QgbWVldCBtaW5pbXVtIGxlbmd0aCBvZiBcIiArIHNjaGVtYS5taW5JdGVtcyxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciBpbnN0YW5jZSBjb250YWlucyBubyBtb3JlIHRoYW4gYSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcywgd2hlbiB0aGUgaW5zdGFuY2UgaXMgYW4gQXJyYXkuXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1N0cmluZ3xudWxsfVxuICovXG52YWxpZGF0b3JzLm1heEl0ZW1zID0gZnVuY3Rpb24gdmFsaWRhdGVNYXhJdGVtcyAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIGlmICghdGhpcy50eXBlcy5hcnJheShpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCEoaW5zdGFuY2UubGVuZ3RoIDw9IHNjaGVtYS5tYXhJdGVtcykpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ21heEl0ZW1zJyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWEubWF4SXRlbXMsXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IG1lZXQgbWF4aW11bSBsZW5ndGggb2YgXCIgKyBzY2hlbWEubWF4SXRlbXMsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVlcCBjb21wYXJlcyBhcnJheXMgZm9yIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB2XG4gKiBAcGFyYW0gaVxuICogQHBhcmFtIGFcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB0ZXN0QXJyYXlzICh2LCBpLCBhKSB7XG4gIHZhciBqLCBsZW4gPSBhLmxlbmd0aDtcbiAgZm9yIChqID0gaSArIDEsIGxlbjsgaiA8IGxlbjsgaisrKSB7XG4gICAgaWYgKGhlbHBlcnMuZGVlcENvbXBhcmVTdHJpY3QodiwgYVtqXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHdoZXRoZXIgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZXMsIHdoZW4gdGhlIGluc3RhbmNlIGlzIGFuIEFycmF5LlxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtTdHJpbmd8bnVsbH1cbiAqL1xudmFsaWRhdG9ycy51bmlxdWVJdGVtcyA9IGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoc2NoZW1hLnVuaXF1ZUl0ZW1zIT09dHJ1ZSkgcmV0dXJuO1xuICBpZiAoIXRoaXMudHlwZXMuYXJyYXkoaW5zdGFuY2UpKSByZXR1cm47XG4gIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gIGlmICghaW5zdGFuY2UuZXZlcnkodGVzdEFycmF5cykpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ3VuaXF1ZUl0ZW1zJyxcbiAgICAgIG1lc3NhZ2U6IFwiY29udGFpbnMgZHVwbGljYXRlIGl0ZW1cIixcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBmb3IgdGhlIHByZXNlbmNlIG9mIGRlcGVuZGVuY3kgcHJvcGVydGllcywgaWYgdGhlIGluc3RhbmNlIGlzIGFuIG9iamVjdC5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge251bGx8VmFsaWRhdG9yUmVzdWx0fVxuICovXG52YWxpZGF0b3JzLmRlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHZhbGlkYXRlRGVwZW5kZW5jaWVzIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKCF0aGlzLnR5cGVzLm9iamVjdChpbnN0YW5jZSkpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IG5ldyBWYWxpZGF0b3JSZXN1bHQoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gc2NoZW1hLmRlcGVuZGVuY2llcykge1xuICAgIGlmIChpbnN0YW5jZVtwcm9wZXJ0eV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBkZXAgPSBzY2hlbWEuZGVwZW5kZW5jaWVzW3Byb3BlcnR5XTtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gY3R4Lm1ha2VDaGlsZChkZXAsIHByb3BlcnR5KTtcbiAgICBpZiAodHlwZW9mIGRlcCA9PSAnc3RyaW5nJykge1xuICAgICAgZGVwID0gW2RlcF07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlcCkpIHtcbiAgICAgIGRlcC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZVtwcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgICAgIC8vIEZJWE1FIHRoZXJlJ3MgdHdvIGRpZmZlcmVudCBcImRlcGVuZGVuY2llc1wiIGVycm9ycyBoZXJlIHdpdGggc2xpZ2h0bHkgZGlmZmVyZW50IG91dHB1dHNcbiAgICAgICAgICAgIC8vIENhbiB3ZSBtYWtlIHRoZXNlIHRoZSBzYW1lPyBPciBzaG91bGQgd2UgY3JlYXRlIGRpZmZlcmVudCBlcnJvciB0eXBlcz9cbiAgICAgICAgICAgIG5hbWU6ICdkZXBlbmRlbmNpZXMnLFxuICAgICAgICAgICAgYXJndW1lbnQ6IGNoaWxkQ29udGV4dC5wcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBcInByb3BlcnR5IFwiICsgcHJvcCArIFwiIG5vdCBmb3VuZCwgcmVxdWlyZWQgYnkgXCIgKyBjaGlsZENvbnRleHQucHJvcGVydHlQYXRoLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIGRlcCwgb3B0aW9ucywgY2hpbGRDb250ZXh0KTtcbiAgICAgIGlmKHJlc3VsdC5pbnN0YW5jZSAhPT0gcmVzLmluc3RhbmNlKSByZXN1bHQuaW5zdGFuY2UgPSByZXMuaW5zdGFuY2U7XG4gICAgICBpZiAocmVzICYmIHJlcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5hZGRFcnJvcih7XG4gICAgICAgICAgbmFtZTogJ2RlcGVuZGVuY2llcycsXG4gICAgICAgICAgYXJndW1lbnQ6IGNoaWxkQ29udGV4dC5wcm9wZXJ0eVBhdGgsXG4gICAgICAgICAgbWVzc2FnZTogXCJkb2VzIG5vdCBtZWV0IGRlcGVuZGVuY3kgcmVxdWlyZWQgYnkgXCIgKyBjaGlsZENvbnRleHQucHJvcGVydHlQYXRoLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LmltcG9ydEVycm9ycyhyZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgdmFsdWUgaXMgb25lIG9mIHRoZSBlbnVtZXJhdGVkIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1ZhbGlkYXRvclJlc3VsdHxudWxsfVxuICovXG52YWxpZGF0b3JzWydlbnVtJ10gPSBmdW5jdGlvbiB2YWxpZGF0ZUVudW0gKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICBpZiAoaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWFbJ2VudW0nXSkpIHtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoXCJlbnVtIGV4cGVjdHMgYW4gYXJyYXlcIiwgc2NoZW1hKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoIXNjaGVtYVsnZW51bSddLnNvbWUoaGVscGVycy5kZWVwQ29tcGFyZVN0cmljdC5iaW5kKG51bGwsIGluc3RhbmNlKSkpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2VudW0nLFxuICAgICAgYXJndW1lbnQ6IHNjaGVtYVsnZW51bSddLFxuICAgICAgbWVzc2FnZTogXCJpcyBub3Qgb25lIG9mIGVudW0gdmFsdWVzOiBcIiArIHNjaGVtYVsnZW51bSddLm1hcChTdHJpbmcpLmpvaW4oJywnKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciB0aGUgaW5zdGFuY2UgZXhhY3RseSBtYXRjaGVzIGEgZ2l2ZW4gdmFsdWVcbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEByZXR1cm4ge1ZhbGlkYXRvclJlc3VsdHxudWxsfVxuICovXG52YWxpZGF0b3JzWydjb25zdCddID0gZnVuY3Rpb24gdmFsaWRhdGVFbnVtIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYgKGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICBpZiAoIWhlbHBlcnMuZGVlcENvbXBhcmVTdHJpY3Qoc2NoZW1hWydjb25zdCddLCBpbnN0YW5jZSkpIHtcbiAgICByZXN1bHQuYWRkRXJyb3Ioe1xuICAgICAgbmFtZTogJ2NvbnN0JyxcbiAgICAgIGFyZ3VtZW50OiBzY2hlbWFbJ2NvbnN0J10sXG4gICAgICBtZXNzYWdlOiBcImRvZXMgbm90IGV4YWN0bHkgbWF0Y2ggZXhwZWN0ZWQgY29uc3RhbnQ6IFwiICsgc2NoZW1hWydjb25zdCddLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyB3aGV0aGVyIHRoZSBpbnN0YW5jZSBpZiBvZiBhIHByb2hpYml0ZWQgdHlwZS5cbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEByZXR1cm4ge251bGx8VmFsaWRhdG9yUmVzdWx0fVxuICovXG52YWxpZGF0b3JzLm5vdCA9IHZhbGlkYXRvcnMuZGlzYWxsb3cgPSBmdW5jdGlvbiB2YWxpZGF0ZU5vdCAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYoaW5zdGFuY2U9PT11bmRlZmluZWQpIHJldHVybiBudWxsO1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuICB2YXIgbm90VHlwZXMgPSBzY2hlbWEubm90IHx8IHNjaGVtYS5kaXNhbGxvdztcbiAgaWYoIW5vdFR5cGVzKSByZXR1cm4gbnVsbDtcbiAgaWYoIUFycmF5LmlzQXJyYXkobm90VHlwZXMpKSBub3RUeXBlcz1bbm90VHlwZXNdO1xuICBub3RUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKHNlbGYudGVzdFR5cGUoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4LCB0eXBlKSkge1xuICAgICAgdmFyIGlkID0gdHlwZSAmJiAodHlwZS4kaWQgfHwgdHlwZS5pZCk7XG4gICAgICB2YXIgc2NoZW1hSWQgPSBpZCB8fCB0eXBlO1xuICAgICAgcmVzdWx0LmFkZEVycm9yKHtcbiAgICAgICAgbmFtZTogJ25vdCcsXG4gICAgICAgIGFyZ3VtZW50OiBzY2hlbWFJZCxcbiAgICAgICAgbWVzc2FnZTogXCJpcyBvZiBwcm9oaWJpdGVkIHR5cGUgXCIgKyBzY2hlbWFJZCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF0dHJpYnV0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///96481\n")},59177:function(module,exports,__webpack_require__){"use strict";eval("\n\nvar uri = __webpack_require__(8575);\n\nvar ValidationError = exports.ValidationError = function ValidationError (message, instance, schema, path, name, argument) {\n  if(Array.isArray(path)){\n    this.path = path;\n    this.property = path.reduce(function(sum, item){\n      return sum + makeSuffix(item);\n    }, 'instance');\n  }else if(path !== undefined){\n    this.property = path;\n  }\n  if (message) {\n    this.message = message;\n  }\n  if (schema) {\n    var id = schema.$id || schema.id;\n    this.schema = id || schema;\n  }\n  if (instance !== undefined) {\n    this.instance = instance;\n  }\n  this.name = name;\n  this.argument = argument;\n  this.stack = this.toString();\n};\n\nValidationError.prototype.toString = function toString() {\n  return this.property + ' ' + this.message;\n};\n\nvar ValidatorResult = exports.ValidatorResult = function ValidatorResult(instance, schema, options, ctx) {\n  this.instance = instance;\n  this.schema = schema;\n  this.options = options;\n  this.path = ctx.path;\n  this.propertyPath = ctx.propertyPath;\n  this.errors = [];\n  this.throwError = options && options.throwError;\n  this.throwFirst = options && options.throwFirst;\n  this.throwAll = options && options.throwAll;\n  this.disableFormat = options && options.disableFormat === true;\n};\n\nValidatorResult.prototype.addError = function addError(detail) {\n  var err;\n  if (typeof detail == 'string') {\n    err = new ValidationError(detail, this.instance, this.schema, this.path);\n  } else {\n    if (!detail) throw new Error('Missing error detail');\n    if (!detail.message) throw new Error('Missing error message');\n    if (!detail.name) throw new Error('Missing validator type');\n    err = new ValidationError(detail.message, this.instance, this.schema, this.path, detail.name, detail.argument);\n  }\n\n  this.errors.push(err);\n  if (this.throwFirst) {\n    throw new ValidatorResultError(this);\n  }else if(this.throwError){\n    throw err;\n  }\n  return err;\n};\n\nValidatorResult.prototype.importErrors = function importErrors(res) {\n  if (typeof res == 'string' || (res && res.validatorType)) {\n    this.addError(res);\n  } else if (res && res.errors) {\n    Array.prototype.push.apply(this.errors, res.errors);\n  }\n};\n\nfunction stringizer (v,i){\n  return i+': '+v.toString()+'\\n';\n}\nValidatorResult.prototype.toString = function toString(res) {\n  return this.errors.map(stringizer).join('');\n};\n\nObject.defineProperty(ValidatorResult.prototype, \"valid\", { get: function() {\n  return !this.errors.length;\n} });\n\nmodule.exports.ValidatorResultError = ValidatorResultError;\nfunction ValidatorResultError(result) {\n  if(Error.captureStackTrace){\n    Error.captureStackTrace(this, ValidatorResultError);\n  }\n  this.instance = result.instance;\n  this.schema = result.schema;\n  this.options = result.options;\n  this.errors = result.errors;\n}\nValidatorResultError.prototype = new Error();\nValidatorResultError.prototype.constructor = ValidatorResultError;\nValidatorResultError.prototype.name = \"Validation Error\";\n\n/**\n * Describes a problem with a Schema which prevents validation of an instance\n * @name SchemaError\n * @constructor\n */\nvar SchemaError = exports.SchemaError = function SchemaError (msg, schema) {\n  this.message = msg;\n  this.schema = schema;\n  Error.call(this, msg);\n  Error.captureStackTrace(this, SchemaError);\n};\nSchemaError.prototype = Object.create(Error.prototype,\n  {\n    constructor: {value: SchemaError, enumerable: false},\n    name: {value: 'SchemaError', enumerable: false},\n  });\n\nvar SchemaContext = exports.SchemaContext = function SchemaContext (schema, options, path, base, schemas) {\n  this.schema = schema;\n  this.options = options;\n  if(Array.isArray(path)){\n    this.path = path;\n    this.propertyPath = path.reduce(function(sum, item){\n      return sum + makeSuffix(item);\n    }, 'instance');\n  }else{\n    this.propertyPath = path;\n  }\n  this.base = base;\n  this.schemas = schemas;\n};\n\nSchemaContext.prototype.resolve = function resolve (target) {\n  return uri.resolve(this.base, target);\n};\n\nSchemaContext.prototype.makeChild = function makeChild(schema, propertyName){\n  var path = (propertyName===undefined) ? this.path : this.path.concat([propertyName]);\n  var id = schema.$id || schema.id;\n  var base = uri.resolve(this.base, id||'');\n  var ctx = new SchemaContext(schema, this.options, path, base, Object.create(this.schemas));\n  if(id && !ctx.schemas[base]){\n    ctx.schemas[base] = schema;\n  }\n  return ctx;\n};\n\nvar FORMAT_REGEXPS = exports.FORMAT_REGEXPS = {\n  'date-time': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])[tT ](2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])(\\.\\d+)?([zZ]|[+-]([0-5][0-9]):(60|[0-5][0-9]))$/,\n  'date': /^\\d{4}-(?:0[0-9]{1}|1[0-2]{1})-(3[01]|0[1-9]|[12][0-9])$/,\n  'time': /^(2[0-4]|[01][0-9]):([0-5][0-9]):(60|[0-5][0-9])$/,\n\n  'email': /^(?:[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/,\n  'ip-address': /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,\n  'ipv6': /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/,\n\n  // TODO: A more accurate regular expression for \"uri\" goes:\n  // [A-Za-z][+\\-.0-9A-Za-z]*:((/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?)?)?#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])|/?%[0-9A-Fa-f]{2}|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*(#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|/(/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\\d*)?|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?:\\d*|\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)?)?\n  'uri': /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$/,\n  'uri-reference': /^(((([A-Za-z][+\\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\\-.0-9A-Za-z]*:?)?)|([A-Za-z][+\\-.0-9A-Za-z]*:)?\\/((%[0-9A-Fa-f]{2}|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?)?))#(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|(([A-Za-z][+\\-.0-9A-Za-z]*)?%[0-9A-Fa-f]{2}|[!$&-.0-9;=@_~]|[A-Za-z][+\\-.0-9A-Za-z]*[!$&-*,;=@_~])(%[0-9A-Fa-f]{2}|[!$&-.0-9;=@-Z_a-z~])*((([/?](%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?#|[/?])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*)?|([A-Za-z][+\\-.0-9A-Za-z]*(:%[0-9A-Fa-f]{2}|:[!$&-.0-;=?-Z_a-z~]|[/?])|\\?)(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|([A-Za-z][+\\-.0-9A-Za-z]*:)?\\/((%[0-9A-Fa-f]{2}|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)(:\\d*)?[/?]|[!$&-.0-;=?-Z_a-z~])(%[0-9A-Fa-f]{2}|[!$&-;=?-Z_a-z~])*|\\/((%[0-9A-Fa-f]{2}|[!$&-.0-9;=A-Z_a-z~])+(:\\d*)?|(\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?:\\d*|\\[(([Vv][0-9A-Fa-f]+\\.[!$&-.0-;=A-Z_a-z~]+)?|[.0-:A-Fa-f]+)\\])?)?|[A-Za-z][+\\-.0-9A-Za-z]*:?)?$/,\n\n  'color': /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/,\n\n  // hostname regex from: http://stackoverflow.com/a/1420225/5628\n  'hostname': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n  'host-name': /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/,\n\n  'alpha': /^[a-zA-Z]+$/,\n  'alphanumeric': /^[a-zA-Z0-9]+$/,\n  'utc-millisec': function (input) {\n    return (typeof input === 'string') && parseFloat(input) === parseInt(input, 10) && !isNaN(input);\n  },\n  'regex': function (input) {\n    var result = true;\n    try {\n      new RegExp(input);\n    } catch (e) {\n      result = false;\n    }\n    return result;\n  },\n  'style': /\\s*(.+?):\\s*([^;]+);?/,\n  'phone': /^\\+(?:[0-9] ?){6,14}[0-9]$/,\n};\n\nFORMAT_REGEXPS.regexp = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.pattern = FORMAT_REGEXPS.regex;\nFORMAT_REGEXPS.ipv4 = FORMAT_REGEXPS['ip-address'];\n\nexports.isFormat = function isFormat (input, format, validator) {\n  if (typeof input === 'string' && FORMAT_REGEXPS[format] !== undefined) {\n    if (FORMAT_REGEXPS[format] instanceof RegExp) {\n      return FORMAT_REGEXPS[format].test(input);\n    }\n    if (typeof FORMAT_REGEXPS[format] === 'function') {\n      return FORMAT_REGEXPS[format](input);\n    }\n  } else if (validator && validator.customFormats &&\n      typeof validator.customFormats[format] === 'function') {\n    return validator.customFormats[format](input);\n  }\n  return true;\n};\n\nvar makeSuffix = exports.makeSuffix = function makeSuffix (key) {\n  key = key.toString();\n  // This function could be capable of outputting valid a ECMAScript string, but the\n  // resulting code for testing which form to use would be tens of thousands of characters long\n  // That means this will use the name form for some illegal forms\n  if (!key.match(/[.\\s\\[\\]]/) && !key.match(/^[\\d]/)) {\n    return '.' + key;\n  }\n  if (key.match(/^\\d+$/)) {\n    return '[' + key + ']';\n  }\n  return '[' + JSON.stringify(key) + ']';\n};\n\nexports.deepCompareStrict = function deepCompareStrict (a, b) {\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b)) {\n      return false;\n    }\n    if (a.length !== b.length) {\n      return false;\n    }\n    return a.every(function (v, i) {\n      return deepCompareStrict(a[i], b[i]);\n    });\n  }\n  if (typeof a === 'object') {\n    if (!a || !b) {\n      return a === b;\n    }\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n    return aKeys.every(function (v) {\n      return deepCompareStrict(a[v], b[v]);\n    });\n  }\n  return a === b;\n};\n\nfunction deepMerger (target, dst, e, i) {\n  if (typeof e === 'object') {\n    dst[i] = deepMerge(target[i], e);\n  } else {\n    if (target.indexOf(e) === -1) {\n      dst.push(e);\n    }\n  }\n}\n\nfunction copyist (src, dst, key) {\n  dst[key] = src[key];\n}\n\nfunction copyistWithDeepMerge (target, src, dst, key) {\n  if (typeof src[key] !== 'object' || !src[key]) {\n    dst[key] = src[key];\n  }\n  else {\n    if (!target[key]) {\n      dst[key] = src[key];\n    } else {\n      dst[key] = deepMerge(target[key], src[key]);\n    }\n  }\n}\n\nfunction deepMerge (target, src) {\n  var array = Array.isArray(src);\n  var dst = array && [] || {};\n\n  if (array) {\n    target = target || [];\n    dst = dst.concat(target);\n    src.forEach(deepMerger.bind(null, target, dst));\n  } else {\n    if (target && typeof target === 'object') {\n      Object.keys(target).forEach(copyist.bind(null, target, dst));\n    }\n    Object.keys(src).forEach(copyistWithDeepMerge.bind(null, target, src, dst));\n  }\n\n  return dst;\n}\n\nmodule.exports.deepMerge = deepMerge;\n\n/**\n * Validates instance against the provided schema\n * Implements URI+JSON Pointer encoding, e.g. \"%7e\"=\"~0\"=>\"~\", \"~1\"=\"%2f\"=>\"/\"\n * @param o\n * @param s The path to walk o along\n * @return any\n */\nexports.objectGetPath = function objectGetPath(o, s) {\n  var parts = s.split('/').slice(1);\n  var k;\n  while (typeof (k=parts.shift()) == 'string') {\n    var n = decodeURIComponent(k.replace(/~0/,'~').replace(/~1/g,'/'));\n    if (!(n in o)) return;\n    o = o[n];\n  }\n  return o;\n};\n\nfunction pathEncoder (v) {\n  return '/'+encodeURIComponent(v).replace(/~/g,'%7E');\n}\n/**\n * Accept an Array of property names and return a JSON Pointer URI fragment\n * @param Array a\n * @return {String}\n */\nexports.encodePath = function encodePointer(a){\n  // ~ must be encoded explicitly because hacks\n  // the slash is encoded by encodeURIComponent\n  return a.map(pathEncoder).join('');\n};\n\n\n/**\n * Calculate the number of decimal places a number uses\n * We need this to get correct results out of multipleOf and divisibleBy\n * when either figure is has decimal places, due to IEEE-754 float issues.\n * @param number\n * @returns {number}\n */\nexports.getDecimalPlaces = function getDecimalPlaces(number) {\n\n  var decimalPlaces = 0;\n  if (isNaN(number)) return decimalPlaces;\n\n  if (typeof number !== 'number') {\n    number = Number(number);\n  }\n\n  var parts = number.toString().split('e');\n  if (parts.length === 2) {\n    if (parts[1][0] !== '-') {\n      return decimalPlaces;\n    } else {\n      decimalPlaces = Number(parts[1].slice(1));\n    }\n  }\n\n  var decimalParts = parts[0].split('.');\n  if (decimalParts.length === 2) {\n    decimalPlaces += decimalParts[1].length;\n  }\n\n  return decimalPlaces;\n};\n\nexports.isSchema = function isSchema(val){\n  return (typeof val === 'object' && val) || (typeof val === 'boolean');\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkxNzcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLElBQUs7O0FBRXZCLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVEO0FBQ0EsR0FBRzs7QUFFSCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RCxXQUFXLHdDQUF3QztBQUNuRCxHQUFHOztBQUVILG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDLG9CQUFvQixFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUU7QUFDN0MsZUFBZSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUU7QUFDeEM7O0FBRUEsaURBQWlELElBQUkseUNBQXlDLElBQUksaURBQWlELEtBQUssa0RBQWtELEtBQUssaUNBQWlDLElBQUksc0JBQXNCLEVBQUUsV0FBVyxJQUFJO0FBQzNSLGlFQUFpRSxFQUFFO0FBQ25FLDhCQUE4QixJQUFJLEdBQUcsRUFBRSxhQUFhLElBQUksbUJBQW1CLElBQUksR0FBRyxFQUFFLGNBQWMsSUFBSSx5RUFBeUUsRUFBRSxvQkFBb0IsSUFBSSxHQUFHLEVBQUUsZ0JBQWdCLElBQUksRUFBRSxJQUFJLDJFQUEyRSxFQUFFLG9CQUFvQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksaUJBQWlCLElBQUksMkVBQTJFLEVBQUUscUJBQXFCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUUscUJBQXFCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUUscUJBQXFCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEVBQUUsSUFBSSxpQkFBaUIsSUFBSSxFQUFFLElBQUkseUVBQXlFLEVBQUUseUJBQXlCLElBQUksRUFBRSxJQUFJLGlCQUFpQixJQUFJLEVBQUUsSUFBSSx5RUFBeUUsRUFBRTs7QUFFampDO0FBQ0Esa0RBQWtELEVBQUUsV0FBVyw2Q0FBNkMsMkRBQTJELEVBQUUsT0FBTyxnQ0FBZ0MsRUFBRSxXQUFXLDZDQUE2QyxzREFBc0QsMkJBQTJCLEVBQUUsVUFBVSx5QkFBeUIsRUFBRSxPQUFPLDRCQUE0QixFQUFFLE9BQU8saUNBQWlDLEVBQUUsV0FBVyxvREFBb0Qsb0VBQW9FO0FBQ3BsQjtBQUNBLGdFQUFnRSxFQUFFLFdBQVcsa0NBQWtDLEVBQUUsT0FBTyx5RkFBeUYsRUFBRSxrQkFBa0IsRUFBRSxXQUFXLDZDQUE2QyxzREFBc0QseUJBQXlCLEVBQUUsT0FBTywrQkFBK0IsRUFBRSxXQUFXLDZDQUE2QywyREFBMkQsRUFBRSxPQUFPLHNEQUFzRCxFQUFFLFdBQVcsc0NBQXNDLG9CQUFvQixFQUFFLFdBQVcsaUNBQWlDLEVBQUUsT0FBTyxtQ0FBbUMsRUFBRSxPQUFPLHVEQUF1RCxFQUFFLFdBQVcsa0NBQWtDLEVBQUUsT0FBTywwREFBMEQsRUFBRSxrQkFBa0IsRUFBRSxXQUFXLDZDQUE2QyxzREFBc0QseUJBQXlCLEVBQUUsT0FBTyw4QkFBOEIsRUFBRSxXQUFXLG9EQUFvRCxvRUFBb0U7O0FBRXR1Qyw2QkFBNkIsRUFBRSxFQUFFLElBQUk7O0FBRXJDO0FBQ0EscUJBQXFCLE1BQU0sa0NBQWtDLEtBQUssa0RBQWtELEtBQUs7QUFDekgsc0JBQXNCLE1BQU0sa0NBQWtDLEtBQUssa0RBQWtELEtBQUs7O0FBRTFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsSUFBSTtBQUNoQywyQkFBMkIsS0FBSztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ucHdkLW51aS8uL25vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi9oZWxwZXJzLmpzPzFmNDQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJpID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSBleHBvcnRzLlZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvciAobWVzc2FnZSwgaW5zdGFuY2UsIHNjaGVtYSwgcGF0aCwgbmFtZSwgYXJndW1lbnQpIHtcbiAgaWYoQXJyYXkuaXNBcnJheShwYXRoKSl7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnByb3BlcnR5ID0gcGF0aC5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBpdGVtKXtcbiAgICAgIHJldHVybiBzdW0gKyBtYWtlU3VmZml4KGl0ZW0pO1xuICAgIH0sICdpbnN0YW5jZScpO1xuICB9ZWxzZSBpZihwYXRoICE9PSB1bmRlZmluZWQpe1xuICAgIHRoaXMucHJvcGVydHkgPSBwYXRoO1xuICB9XG4gIGlmIChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuICBpZiAoc2NoZW1hKSB7XG4gICAgdmFyIGlkID0gc2NoZW1hLiRpZCB8fCBzY2hlbWEuaWQ7XG4gICAgdGhpcy5zY2hlbWEgPSBpZCB8fCBzY2hlbWE7XG4gIH1cbiAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIH1cbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB0aGlzLnN0YWNrID0gdGhpcy50b1N0cmluZygpO1xufTtcblxuVmFsaWRhdGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdGhpcy5wcm9wZXJ0eSArICcgJyArIHRoaXMubWVzc2FnZTtcbn07XG5cbnZhciBWYWxpZGF0b3JSZXN1bHQgPSBleHBvcnRzLlZhbGlkYXRvclJlc3VsdCA9IGZ1bmN0aW9uIFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5wYXRoID0gY3R4LnBhdGg7XG4gIHRoaXMucHJvcGVydHlQYXRoID0gY3R4LnByb3BlcnR5UGF0aDtcbiAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgdGhpcy50aHJvd0Vycm9yID0gb3B0aW9ucyAmJiBvcHRpb25zLnRocm93RXJyb3I7XG4gIHRoaXMudGhyb3dGaXJzdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aHJvd0ZpcnN0O1xuICB0aGlzLnRocm93QWxsID0gb3B0aW9ucyAmJiBvcHRpb25zLnRocm93QWxsO1xuICB0aGlzLmRpc2FibGVGb3JtYXQgPSBvcHRpb25zICYmIG9wdGlvbnMuZGlzYWJsZUZvcm1hdCA9PT0gdHJ1ZTtcbn07XG5cblZhbGlkYXRvclJlc3VsdC5wcm90b3R5cGUuYWRkRXJyb3IgPSBmdW5jdGlvbiBhZGRFcnJvcihkZXRhaWwpIHtcbiAgdmFyIGVycjtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT0gJ3N0cmluZycpIHtcbiAgICBlcnIgPSBuZXcgVmFsaWRhdGlvbkVycm9yKGRldGFpbCwgdGhpcy5pbnN0YW5jZSwgdGhpcy5zY2hlbWEsIHRoaXMucGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFkZXRhaWwpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlcnJvciBkZXRhaWwnKTtcbiAgICBpZiAoIWRldGFpbC5tZXNzYWdlKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZXJyb3IgbWVzc2FnZScpO1xuICAgIGlmICghZGV0YWlsLm5hbWUpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2YWxpZGF0b3IgdHlwZScpO1xuICAgIGVyciA9IG5ldyBWYWxpZGF0aW9uRXJyb3IoZGV0YWlsLm1lc3NhZ2UsIHRoaXMuaW5zdGFuY2UsIHRoaXMuc2NoZW1hLCB0aGlzLnBhdGgsIGRldGFpbC5uYW1lLCBkZXRhaWwuYXJndW1lbnQpO1xuICB9XG5cbiAgdGhpcy5lcnJvcnMucHVzaChlcnIpO1xuICBpZiAodGhpcy50aHJvd0ZpcnN0KSB7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRvclJlc3VsdEVycm9yKHRoaXMpO1xuICB9ZWxzZSBpZih0aGlzLnRocm93RXJyb3Ipe1xuICAgIHRocm93IGVycjtcbiAgfVxuICByZXR1cm4gZXJyO1xufTtcblxuVmFsaWRhdG9yUmVzdWx0LnByb3RvdHlwZS5pbXBvcnRFcnJvcnMgPSBmdW5jdGlvbiBpbXBvcnRFcnJvcnMocmVzKSB7XG4gIGlmICh0eXBlb2YgcmVzID09ICdzdHJpbmcnIHx8IChyZXMgJiYgcmVzLnZhbGlkYXRvclR5cGUpKSB7XG4gICAgdGhpcy5hZGRFcnJvcihyZXMpO1xuICB9IGVsc2UgaWYgKHJlcyAmJiByZXMuZXJyb3JzKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5lcnJvcnMsIHJlcy5lcnJvcnMpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdpemVyICh2LGkpe1xuICByZXR1cm4gaSsnOiAnK3YudG9TdHJpbmcoKSsnXFxuJztcbn1cblZhbGlkYXRvclJlc3VsdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyZXMpIHtcbiAgcmV0dXJuIHRoaXMuZXJyb3JzLm1hcChzdHJpbmdpemVyKS5qb2luKCcnKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0b3JSZXN1bHQucHJvdG90eXBlLCBcInZhbGlkXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG59IH0pO1xuXG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0b3JSZXN1bHRFcnJvciA9IFZhbGlkYXRvclJlc3VsdEVycm9yO1xuZnVuY3Rpb24gVmFsaWRhdG9yUmVzdWx0RXJyb3IocmVzdWx0KSB7XG4gIGlmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKXtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBWYWxpZGF0b3JSZXN1bHRFcnJvcik7XG4gIH1cbiAgdGhpcy5pbnN0YW5jZSA9IHJlc3VsdC5pbnN0YW5jZTtcbiAgdGhpcy5zY2hlbWEgPSByZXN1bHQuc2NoZW1hO1xuICB0aGlzLm9wdGlvbnMgPSByZXN1bHQub3B0aW9ucztcbiAgdGhpcy5lcnJvcnMgPSByZXN1bHQuZXJyb3JzO1xufVxuVmFsaWRhdG9yUmVzdWx0RXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5WYWxpZGF0b3JSZXN1bHRFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWYWxpZGF0b3JSZXN1bHRFcnJvcjtcblZhbGlkYXRvclJlc3VsdEVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJWYWxpZGF0aW9uIEVycm9yXCI7XG5cbi8qKlxuICogRGVzY3JpYmVzIGEgcHJvYmxlbSB3aXRoIGEgU2NoZW1hIHdoaWNoIHByZXZlbnRzIHZhbGlkYXRpb24gb2YgYW4gaW5zdGFuY2VcbiAqIEBuYW1lIFNjaGVtYUVycm9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNjaGVtYUVycm9yID0gZXhwb3J0cy5TY2hlbWFFcnJvciA9IGZ1bmN0aW9uIFNjaGVtYUVycm9yIChtc2csIHNjaGVtYSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICBFcnJvci5jYWxsKHRoaXMsIG1zZyk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFNjaGVtYUVycm9yKTtcbn07XG5TY2hlbWFFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSxcbiAge1xuICAgIGNvbnN0cnVjdG9yOiB7dmFsdWU6IFNjaGVtYUVycm9yLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG4gICAgbmFtZToge3ZhbHVlOiAnU2NoZW1hRXJyb3InLCBlbnVtZXJhYmxlOiBmYWxzZX0sXG4gIH0pO1xuXG52YXIgU2NoZW1hQ29udGV4dCA9IGV4cG9ydHMuU2NoZW1hQ29udGV4dCA9IGZ1bmN0aW9uIFNjaGVtYUNvbnRleHQgKHNjaGVtYSwgb3B0aW9ucywgcGF0aCwgYmFzZSwgc2NoZW1hcykge1xuICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgaWYoQXJyYXkuaXNBcnJheShwYXRoKSl7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLnByb3BlcnR5UGF0aCA9IHBhdGgucmVkdWNlKGZ1bmN0aW9uKHN1bSwgaXRlbSl7XG4gICAgICByZXR1cm4gc3VtICsgbWFrZVN1ZmZpeChpdGVtKTtcbiAgICB9LCAnaW5zdGFuY2UnKTtcbiAgfWVsc2V7XG4gICAgdGhpcy5wcm9wZXJ0eVBhdGggPSBwYXRoO1xuICB9XG4gIHRoaXMuYmFzZSA9IGJhc2U7XG4gIHRoaXMuc2NoZW1hcyA9IHNjaGVtYXM7XG59O1xuXG5TY2hlbWFDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSAodGFyZ2V0KSB7XG4gIHJldHVybiB1cmkucmVzb2x2ZSh0aGlzLmJhc2UsIHRhcmdldCk7XG59O1xuXG5TY2hlbWFDb250ZXh0LnByb3RvdHlwZS5tYWtlQ2hpbGQgPSBmdW5jdGlvbiBtYWtlQ2hpbGQoc2NoZW1hLCBwcm9wZXJ0eU5hbWUpe1xuICB2YXIgcGF0aCA9IChwcm9wZXJ0eU5hbWU9PT11bmRlZmluZWQpID8gdGhpcy5wYXRoIDogdGhpcy5wYXRoLmNvbmNhdChbcHJvcGVydHlOYW1lXSk7XG4gIHZhciBpZCA9IHNjaGVtYS4kaWQgfHwgc2NoZW1hLmlkO1xuICB2YXIgYmFzZSA9IHVyaS5yZXNvbHZlKHRoaXMuYmFzZSwgaWR8fCcnKTtcbiAgdmFyIGN0eCA9IG5ldyBTY2hlbWFDb250ZXh0KHNjaGVtYSwgdGhpcy5vcHRpb25zLCBwYXRoLCBiYXNlLCBPYmplY3QuY3JlYXRlKHRoaXMuc2NoZW1hcykpO1xuICBpZihpZCAmJiAhY3R4LnNjaGVtYXNbYmFzZV0pe1xuICAgIGN0eC5zY2hlbWFzW2Jhc2VdID0gc2NoZW1hO1xuICB9XG4gIHJldHVybiBjdHg7XG59O1xuXG52YXIgRk9STUFUX1JFR0VYUFMgPSBleHBvcnRzLkZPUk1BVF9SRUdFWFBTID0ge1xuICAnZGF0ZS10aW1lJzogL15cXGR7NH0tKD86MFswLTldezF9fDFbMC0yXXsxfSktKDNbMDFdfDBbMS05XXxbMTJdWzAtOV0pW3RUIF0oMlswLTRdfFswMV1bMC05XSk6KFswLTVdWzAtOV0pOig2MHxbMC01XVswLTldKShcXC5cXGQrKT8oW3paXXxbKy1dKFswLTVdWzAtOV0pOig2MHxbMC01XVswLTldKSkkLyxcbiAgJ2RhdGUnOiAvXlxcZHs0fS0oPzowWzAtOV17MX18MVswLTJdezF9KS0oM1swMV18MFsxLTldfFsxMl1bMC05XSkkLyxcbiAgJ3RpbWUnOiAvXigyWzAtNF18WzAxXVswLTldKTooWzAtNV1bMC05XSk6KDYwfFswLTVdWzAtOV0pJC8sXG5cbiAgJ2VtYWlsJzogL14oPzpbXFx3XFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwtXFwvXFw9XFw/XFxeXFxgXFx7XFx8XFx9XFx+XStcXC4pKltcXHdcXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC1cXC9cXD1cXD9cXF5cXGBcXHtcXHxcXH1cXH5dK0AoPzooPzooPzpbYS16QS1aMC05XSg/OlthLXpBLVowLTlcXC1dKD8hXFwuKSl7MCw2MX1bYS16QS1aMC05XT9cXC4pK1thLXpBLVowLTldKD86W2EtekEtWjAtOVxcLV0oPyEkKSl7MCw2MX1bYS16QS1aMC05XT8pfCg/OlxcWyg/Oig/OlswMV0/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pXFwuKXszfSg/OlswMV0/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pXFxdKSkkLyxcbiAgJ2lwLWFkZHJlc3MnOiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KSQvLFxuICAnaXB2Nic6IC9eXFxzKigoKFswLTlBLUZhLWZdezEsNH06KXs3fShbMC05QS1GYS1mXXsxLDR9fDopKXwoKFswLTlBLUZhLWZdezEsNH06KXs2fSg6WzAtOUEtRmEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezV9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezR9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsM30pfCgoOlswLTlBLUZhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlBLUZhLWZdezEsNH06KXszfSgoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOUEtRmEtZl17MSw0fTopezJ9KCgoOlswLTlBLUZhLWZdezEsNH0pezEsNX0pfCgoOlswLTlBLUZhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05QS1GYS1mXXsxLDR9Oil7MX0oKCg6WzAtOUEtRmEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOUEtRmEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05QS1GYS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05QS1GYS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSglLispP1xccyokLyxcblxuICAvLyBUT0RPOiBBIG1vcmUgYWNjdXJhdGUgcmVndWxhciBleHByZXNzaW9uIGZvciBcInVyaVwiIGdvZXM6XG4gIC8vIFtBLVphLXpdWytcXC0uMC05QS1aYS16XSo6KCgvKC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+XSkrfChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pKDpcXGQqKT8pPyk/IyglWzAtOUEtRmEtZl17Mn18WyEkJi07PT8tWl9hLXp+XSkqfCgvKC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+XSkrfChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pKDpcXGQqKT9bLz9dfFshJCYtLjAtOz0/LVpfYS16fl0pfC8/JVswLTlBLUZhLWZdezJ9fFshJCYtLjAtOz0/LVpfYS16fl0pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSooIyglWzAtOUEtRmEtZl17Mn18WyEkJi07PT8tWl9hLXp+XSkqKT98LygvKCglWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1BLVpfYS16fl0pKyg6XFxkKik/fChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT86XFxkKnxcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pPyk/XG4gICd1cmknOiAvXlthLXpBLVpdW2EtekEtWjAtOSstLl0qOlteXFxzXSokLyxcbiAgJ3VyaS1yZWZlcmVuY2UnOiAvXigoKChbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qKDolWzAtOUEtRmEtZl17Mn18OlshJCYtLjAtOz0/LVpfYS16fl18Wy8/XSl8XFw/KSglWzAtOUEtRmEtZl17Mn18WyEkJi07PT8tWl9hLXp+XSkqfChbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qOj8pPyl8KFtBLVphLXpdWytcXC0uMC05QS1aYS16XSo6KT9cXC8oKCVbMC05QS1GYS1mXXsyfXxcXC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+XSkrfChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pKDpcXGQqKT9bLz9dfFshJCYtLjAtOz0/LVpfYS16fl0pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSp8KFxcLygoJVswLTlBLUZhLWZdezJ9fFshJCYtLjAtOTs9QS1aX2Eten5dKSt8KFxcWygoW1Z2XVswLTlBLUZhLWZdK1xcLlshJCYtLjAtOz1BLVpfYS16fl0rKT98Wy4wLTpBLUZhLWZdKylcXF0pPykoOlxcZCopPyk/KSkjKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSp8KChbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qKT8lWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1AX35dfFtBLVphLXpdWytcXC0uMC05QS1aYS16XSpbISQmLSosOz1AX35dKSglWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1ALVpfYS16fl0pKigoKFsvP10oJVswLTlBLUZhLWZdezJ9fFshJCYtOz0/LVpfYS16fl0pKik/I3xbLz9dKSglWzAtOUEtRmEtZl17Mn18WyEkJi07PT8tWl9hLXp+XSkqKT98KFtBLVphLXpdWytcXC0uMC05QS1aYS16XSooOiVbMC05QS1GYS1mXXsyfXw6WyEkJi0uMC07PT8tWl9hLXp+XXxbLz9dKXxcXD8pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSp8KFtBLVphLXpdWytcXC0uMC05QS1aYS16XSo6KT9cXC8oKCVbMC05QS1GYS1mXXsyfXxcXC8oKCVbMC05QS1GYS1mXXsyfXxbISQmLS4wLTk7PUEtWl9hLXp+XSkrfChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pKDpcXGQqKT9bLz9dfFshJCYtLjAtOz0/LVpfYS16fl0pKCVbMC05QS1GYS1mXXsyfXxbISQmLTs9Py1aX2Eten5dKSp8XFwvKCglWzAtOUEtRmEtZl17Mn18WyEkJi0uMC05Oz1BLVpfYS16fl0pKyg6XFxkKik/fChcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT86XFxkKnxcXFsoKFtWdl1bMC05QS1GYS1mXStcXC5bISQmLS4wLTs9QS1aX2Eten5dKyk/fFsuMC06QS1GYS1mXSspXFxdKT8pP3xbQS1aYS16XVsrXFwtLjAtOUEtWmEtel0qOj8pPyQvLFxuXG4gICdjb2xvcic6IC9eKCM/KFswLTlBLUZhLWZdezN9KXsxLDJ9XFxifGFxdWF8YmxhY2t8Ymx1ZXxmdWNoc2lhfGdyYXl8Z3JlZW58bGltZXxtYXJvb258bmF2eXxvbGl2ZXxvcmFuZ2V8cHVycGxlfHJlZHxzaWx2ZXJ8dGVhbHx3aGl0ZXx5ZWxsb3d8KHJnYlxcKFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccyosXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKixcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqXFwpKXwocmdiXFwoXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqLFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKixcXHMqKFxcZD9cXGQlfDEwMCUpK1xccypcXCkpKSQvLFxuXG4gIC8vIGhvc3RuYW1lIHJlZ2V4IGZyb206IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE0MjAyMjUvNTYyOFxuICAnaG9zdG5hbWUnOiAvXig/PS57MSwyNTV9JClbMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPyg/OlxcLlswLTlBLVphLXpdKD86KD86WzAtOUEtWmEtel18LSl7MCw2MX1bMC05QS1aYS16XSk/KSpcXC4/JC8sXG4gICdob3N0LW5hbWUnOiAvXig/PS57MSwyNTV9JClbMC05QS1aYS16XSg/Oig/OlswLTlBLVphLXpdfC0pezAsNjF9WzAtOUEtWmEtel0pPyg/OlxcLlswLTlBLVphLXpdKD86KD86WzAtOUEtWmEtel18LSl7MCw2MX1bMC05QS1aYS16XSk/KSpcXC4/JC8sXG5cbiAgJ2FscGhhJzogL15bYS16QS1aXSskLyxcbiAgJ2FscGhhbnVtZXJpYyc6IC9eW2EtekEtWjAtOV0rJC8sXG4gICd1dGMtbWlsbGlzZWMnOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpICYmIHBhcnNlRmxvYXQoaW5wdXQpID09PSBwYXJzZUludChpbnB1dCwgMTApICYmICFpc05hTihpbnB1dCk7XG4gIH0sXG4gICdyZWdleCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBuZXcgUmVnRXhwKGlucHV0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgJ3N0eWxlJzogL1xccyooLis/KTpcXHMqKFteO10rKTs/LyxcbiAgJ3Bob25lJzogL15cXCsoPzpbMC05XSA/KXs2LDE0fVswLTldJC8sXG59O1xuXG5GT1JNQVRfUkVHRVhQUy5yZWdleHAgPSBGT1JNQVRfUkVHRVhQUy5yZWdleDtcbkZPUk1BVF9SRUdFWFBTLnBhdHRlcm4gPSBGT1JNQVRfUkVHRVhQUy5yZWdleDtcbkZPUk1BVF9SRUdFWFBTLmlwdjQgPSBGT1JNQVRfUkVHRVhQU1snaXAtYWRkcmVzcyddO1xuXG5leHBvcnRzLmlzRm9ybWF0ID0gZnVuY3Rpb24gaXNGb3JtYXQgKGlucHV0LCBmb3JtYXQsIHZhbGlkYXRvcikge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyAmJiBGT1JNQVRfUkVHRVhQU1tmb3JtYXRdICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoRk9STUFUX1JFR0VYUFNbZm9ybWF0XSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIEZPUk1BVF9SRUdFWFBTW2Zvcm1hdF0udGVzdChpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRk9STUFUX1JFR0VYUFNbZm9ybWF0XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIEZPUk1BVF9SRUdFWFBTW2Zvcm1hdF0oaW5wdXQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWxpZGF0b3IgJiYgdmFsaWRhdG9yLmN1c3RvbUZvcm1hdHMgJiZcbiAgICAgIHR5cGVvZiB2YWxpZGF0b3IuY3VzdG9tRm9ybWF0c1tmb3JtYXRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvci5jdXN0b21Gb3JtYXRzW2Zvcm1hdF0oaW5wdXQpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIG1ha2VTdWZmaXggPSBleHBvcnRzLm1ha2VTdWZmaXggPSBmdW5jdGlvbiBtYWtlU3VmZml4IChrZXkpIHtcbiAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XG4gIC8vIFRoaXMgZnVuY3Rpb24gY291bGQgYmUgY2FwYWJsZSBvZiBvdXRwdXR0aW5nIHZhbGlkIGEgRUNNQVNjcmlwdCBzdHJpbmcsIGJ1dCB0aGVcbiAgLy8gcmVzdWx0aW5nIGNvZGUgZm9yIHRlc3Rpbmcgd2hpY2ggZm9ybSB0byB1c2Ugd291bGQgYmUgdGVucyBvZiB0aG91c2FuZHMgb2YgY2hhcmFjdGVycyBsb25nXG4gIC8vIFRoYXQgbWVhbnMgdGhpcyB3aWxsIHVzZSB0aGUgbmFtZSBmb3JtIGZvciBzb21lIGlsbGVnYWwgZm9ybXNcbiAgaWYgKCFrZXkubWF0Y2goL1suXFxzXFxbXFxdXS8pICYmICFrZXkubWF0Y2goL15bXFxkXS8pKSB7XG4gICAgcmV0dXJuICcuJyArIGtleTtcbiAgfVxuICBpZiAoa2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgIHJldHVybiAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgcmV0dXJuICdbJyArIEpTT04uc3RyaW5naWZ5KGtleSkgKyAnXSc7XG59O1xuXG5leHBvcnRzLmRlZXBDb21wYXJlU3RyaWN0ID0gZnVuY3Rpb24gZGVlcENvbXBhcmVTdHJpY3QgKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhLmV2ZXJ5KGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICByZXR1cm4gZGVlcENvbXBhcmVTdHJpY3QoYVtpXSwgYltpXSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhID09PSAnb2JqZWN0Jykge1xuICAgIGlmICghYSB8fCAhYikge1xuICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgfVxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBkZWVwQ29tcGFyZVN0cmljdChhW3ZdLCBiW3ZdKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn07XG5cbmZ1bmN0aW9uIGRlZXBNZXJnZXIgKHRhcmdldCwgZHN0LCBlLCBpKSB7XG4gIGlmICh0eXBlb2YgZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkc3RbaV0gPSBkZWVwTWVyZ2UodGFyZ2V0W2ldLCBlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGFyZ2V0LmluZGV4T2YoZSkgPT09IC0xKSB7XG4gICAgICBkc3QucHVzaChlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weWlzdCAoc3JjLCBkc3QsIGtleSkge1xuICBkc3Rba2V5XSA9IHNyY1trZXldO1xufVxuXG5mdW5jdGlvbiBjb3B5aXN0V2l0aERlZXBNZXJnZSAodGFyZ2V0LCBzcmMsIGRzdCwga2V5KSB7XG4gIGlmICh0eXBlb2Ygc3JjW2tleV0gIT09ICdvYmplY3QnIHx8ICFzcmNba2V5XSkge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHN0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0W2tleV0sIHNyY1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVlcE1lcmdlICh0YXJnZXQsIHNyYykge1xuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KHNyYyk7XG4gIHZhciBkc3QgPSBhcnJheSAmJiBbXSB8fCB7fTtcblxuICBpZiAoYXJyYXkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgW107XG4gICAgZHN0ID0gZHN0LmNvbmNhdCh0YXJnZXQpO1xuICAgIHNyYy5mb3JFYWNoKGRlZXBNZXJnZXIuYmluZChudWxsLCB0YXJnZXQsIGRzdCkpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRhcmdldCkuZm9yRWFjaChjb3B5aXN0LmJpbmQobnVsbCwgdGFyZ2V0LCBkc3QpKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGNvcHlpc3RXaXRoRGVlcE1lcmdlLmJpbmQobnVsbCwgdGFyZ2V0LCBzcmMsIGRzdCkpO1xuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMuZGVlcE1lcmdlID0gZGVlcE1lcmdlO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBwcm92aWRlZCBzY2hlbWFcbiAqIEltcGxlbWVudHMgVVJJK0pTT04gUG9pbnRlciBlbmNvZGluZywgZS5nLiBcIiU3ZVwiPVwifjBcIj0+XCJ+XCIsIFwifjFcIj1cIiUyZlwiPT5cIi9cIlxuICogQHBhcmFtIG9cbiAqIEBwYXJhbSBzIFRoZSBwYXRoIHRvIHdhbGsgbyBhbG9uZ1xuICogQHJldHVybiBhbnlcbiAqL1xuZXhwb3J0cy5vYmplY3RHZXRQYXRoID0gZnVuY3Rpb24gb2JqZWN0R2V0UGF0aChvLCBzKSB7XG4gIHZhciBwYXJ0cyA9IHMuc3BsaXQoJy8nKS5zbGljZSgxKTtcbiAgdmFyIGs7XG4gIHdoaWxlICh0eXBlb2YgKGs9cGFydHMuc2hpZnQoKSkgPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbiA9IGRlY29kZVVSSUNvbXBvbmVudChrLnJlcGxhY2UoL34wLywnficpLnJlcGxhY2UoL34xL2csJy8nKSk7XG4gICAgaWYgKCEobiBpbiBvKSkgcmV0dXJuO1xuICAgIG8gPSBvW25dO1xuICB9XG4gIHJldHVybiBvO1xufTtcblxuZnVuY3Rpb24gcGF0aEVuY29kZXIgKHYpIHtcbiAgcmV0dXJuICcvJytlbmNvZGVVUklDb21wb25lbnQodikucmVwbGFjZSgvfi9nLCclN0UnKTtcbn1cbi8qKlxuICogQWNjZXB0IGFuIEFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCByZXR1cm4gYSBKU09OIFBvaW50ZXIgVVJJIGZyYWdtZW50XG4gKiBAcGFyYW0gQXJyYXkgYVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmVuY29kZVBhdGggPSBmdW5jdGlvbiBlbmNvZGVQb2ludGVyKGEpe1xuICAvLyB+IG11c3QgYmUgZW5jb2RlZCBleHBsaWNpdGx5IGJlY2F1c2UgaGFja3NcbiAgLy8gdGhlIHNsYXNoIGlzIGVuY29kZWQgYnkgZW5jb2RlVVJJQ29tcG9uZW50XG4gIHJldHVybiBhLm1hcChwYXRoRW5jb2Rlcikuam9pbignJyk7XG59O1xuXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgYSBudW1iZXIgdXNlc1xuICogV2UgbmVlZCB0aGlzIHRvIGdldCBjb3JyZWN0IHJlc3VsdHMgb3V0IG9mIG11bHRpcGxlT2YgYW5kIGRpdmlzaWJsZUJ5XG4gKiB3aGVuIGVpdGhlciBmaWd1cmUgaXMgaGFzIGRlY2ltYWwgcGxhY2VzLCBkdWUgdG8gSUVFRS03NTQgZmxvYXQgaXNzdWVzLlxuICogQHBhcmFtIG51bWJlclxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXREZWNpbWFsUGxhY2VzID0gZnVuY3Rpb24gZ2V0RGVjaW1hbFBsYWNlcyhudW1iZXIpIHtcblxuICB2YXIgZGVjaW1hbFBsYWNlcyA9IDA7XG4gIGlmIChpc05hTihudW1iZXIpKSByZXR1cm4gZGVjaW1hbFBsYWNlcztcblxuICBpZiAodHlwZW9mIG51bWJlciAhPT0gJ251bWJlcicpIHtcbiAgICBudW1iZXIgPSBOdW1iZXIobnVtYmVyKTtcbiAgfVxuXG4gIHZhciBwYXJ0cyA9IG51bWJlci50b1N0cmluZygpLnNwbGl0KCdlJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAocGFydHNbMV1bMF0gIT09ICctJykge1xuICAgICAgcmV0dXJuIGRlY2ltYWxQbGFjZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2ltYWxQbGFjZXMgPSBOdW1iZXIocGFydHNbMV0uc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWNpbWFsUGFydHMgPSBwYXJ0c1swXS5zcGxpdCgnLicpO1xuICBpZiAoZGVjaW1hbFBhcnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGRlY2ltYWxQbGFjZXMgKz0gZGVjaW1hbFBhcnRzWzFdLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBkZWNpbWFsUGxhY2VzO1xufTtcblxuZXhwb3J0cy5pc1NjaGVtYSA9IGZ1bmN0aW9uIGlzU2NoZW1hKHZhbCl7XG4gIHJldHVybiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsKSB8fCAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKTtcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59177\n")},40660:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar Validator = module.exports.Validator = __webpack_require__(43058);\n\nmodule.exports.ValidatorResult = __webpack_require__(59177).ValidatorResult;\nmodule.exports.ValidatorResultError = __webpack_require__(59177).ValidatorResultError;\nmodule.exports.ValidationError = __webpack_require__(59177).ValidationError;\nmodule.exports.SchemaError = __webpack_require__(59177).SchemaError;\nmodule.exports.SchemaScanResult = __webpack_require__(31287).SchemaScanResult;\nmodule.exports.scan = __webpack_require__(31287).scan;\n\nmodule.exports.validate = function (instance, schema, options) {\n  var v = new Validator();\n  return v.validate(instance, schema, options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA2NjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLHFEQUFpRDs7QUFFakUsMkVBQXFFO0FBQ3JFLHFGQUErRTtBQUMvRSwyRUFBcUU7QUFDckUsbUVBQTZEO0FBQzdELDZFQUFvRTtBQUNwRSxxREFBNEM7O0FBRTVDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ucHdkLW51aS8uL25vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi9pbmRleC5qcz9hNDFiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFZhbGlkYXRvciA9IG1vZHVsZS5leHBvcnRzLlZhbGlkYXRvciA9IHJlcXVpcmUoJy4vdmFsaWRhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzLlZhbGlkYXRvclJlc3VsdCA9IHJlcXVpcmUoJy4vaGVscGVycycpLlZhbGlkYXRvclJlc3VsdDtcbm1vZHVsZS5leHBvcnRzLlZhbGlkYXRvclJlc3VsdEVycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzJykuVmFsaWRhdG9yUmVzdWx0RXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMnKS5WYWxpZGF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5TY2hlbWFFcnJvciA9IHJlcXVpcmUoJy4vaGVscGVycycpLlNjaGVtYUVycm9yO1xubW9kdWxlLmV4cG9ydHMuU2NoZW1hU2NhblJlc3VsdCA9IHJlcXVpcmUoJy4vc2NhbicpLlNjaGVtYVNjYW5SZXN1bHQ7XG5tb2R1bGUuZXhwb3J0cy5zY2FuID0gcmVxdWlyZSgnLi9zY2FuJykuc2NhbjtcblxubW9kdWxlLmV4cG9ydHMudmFsaWRhdGUgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucykge1xuICB2YXIgdiA9IG5ldyBWYWxpZGF0b3IoKTtcbiAgcmV0dXJuIHYudmFsaWRhdGUoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40660\n")},31287:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar urilib = __webpack_require__(8575);\nvar helpers = __webpack_require__(59177);\n\nmodule.exports.SchemaScanResult = SchemaScanResult;\nfunction SchemaScanResult(found, ref){\n  this.id = found;\n  this.ref = ref;\n}\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param string uri\n * @param object schema\n * @return {Object}\n */\nmodule.exports.scan = function scan(base, schema){\n  function scanSchema(baseuri, schema){\n    if(!schema || typeof schema!='object') return;\n    // Mark all referenced schemas so we can tell later which schemas are referred to, but never defined\n    if(schema.$ref){\n      var resolvedUri = urilib.resolve(baseuri, schema.$ref);\n      ref[resolvedUri] = ref[resolvedUri] ? ref[resolvedUri]+1 : 0;\n      return;\n    }\n    var id = schema.$id || schema.id;\n    var ourBase = id ? urilib.resolve(baseuri, id) : baseuri;\n    if (ourBase) {\n      // If there's no fragment, append an empty one\n      if(ourBase.indexOf('#')<0) ourBase += '#';\n      if(found[ourBase]){\n        if(!helpers.deepCompareStrict(found[ourBase], schema)){\n          throw new Error('Schema <'+ourBase+'> already exists with different definition');\n        }\n        return found[ourBase];\n      }\n      found[ourBase] = schema;\n      // strip trailing fragment\n      if(ourBase[ourBase.length-1]=='#'){\n        found[ourBase.substring(0, ourBase.length-1)] = schema;\n      }\n    }\n    scanArray(ourBase+'/items', (Array.isArray(schema.items)?schema.items:[schema.items]));\n    scanArray(ourBase+'/extends', (Array.isArray(schema.extends)?schema.extends:[schema.extends]));\n    scanSchema(ourBase+'/additionalItems', schema.additionalItems);\n    scanObject(ourBase+'/properties', schema.properties);\n    scanSchema(ourBase+'/additionalProperties', schema.additionalProperties);\n    scanObject(ourBase+'/definitions', schema.definitions);\n    scanObject(ourBase+'/patternProperties', schema.patternProperties);\n    scanObject(ourBase+'/dependencies', schema.dependencies);\n    scanArray(ourBase+'/disallow', schema.disallow);\n    scanArray(ourBase+'/allOf', schema.allOf);\n    scanArray(ourBase+'/anyOf', schema.anyOf);\n    scanArray(ourBase+'/oneOf', schema.oneOf);\n    scanSchema(ourBase+'/not', schema.not);\n  }\n  function scanArray(baseuri, schemas){\n    if(!Array.isArray(schemas)) return;\n    for(var i=0; i<schemas.length; i++){\n      scanSchema(baseuri+'/'+i, schemas[i]);\n    }\n  }\n  function scanObject(baseuri, schemas){\n    if(!schemas || typeof schemas!='object') return;\n    for(var p in schemas){\n      scanSchema(baseuri+'/'+p, schemas[p]);\n    }\n  }\n\n  var found = {};\n  var ref = {};\n  scanSchema(base, schema);\n  return new SchemaScanResult(found, ref);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEyODcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLElBQUs7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLEtBQVc7O0FBRWpDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25wd2QtbnVpLy4vbm9kZV9tb2R1bGVzL2pzb25zY2hlbWEvbGliL3NjYW4uanM/MGQzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIHVyaWxpYiA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMuU2NoZW1hU2NhblJlc3VsdCA9IFNjaGVtYVNjYW5SZXN1bHQ7XG5mdW5jdGlvbiBTY2hlbWFTY2FuUmVzdWx0KGZvdW5kLCByZWYpe1xuICB0aGlzLmlkID0gZm91bmQ7XG4gIHRoaXMucmVmID0gcmVmO1xufVxuXG4vKipcbiAqIEFkZHMgYSBzY2hlbWEgd2l0aCBhIGNlcnRhaW4gdXJuIHRvIHRoZSBWYWxpZGF0b3IgaW5zdGFuY2UuXG4gKiBAcGFyYW0gc3RyaW5nIHVyaVxuICogQHBhcmFtIG9iamVjdCBzY2hlbWFcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xubW9kdWxlLmV4cG9ydHMuc2NhbiA9IGZ1bmN0aW9uIHNjYW4oYmFzZSwgc2NoZW1hKXtcbiAgZnVuY3Rpb24gc2NhblNjaGVtYShiYXNldXJpLCBzY2hlbWEpe1xuICAgIGlmKCFzY2hlbWEgfHwgdHlwZW9mIHNjaGVtYSE9J29iamVjdCcpIHJldHVybjtcbiAgICAvLyBNYXJrIGFsbCByZWZlcmVuY2VkIHNjaGVtYXMgc28gd2UgY2FuIHRlbGwgbGF0ZXIgd2hpY2ggc2NoZW1hcyBhcmUgcmVmZXJyZWQgdG8sIGJ1dCBuZXZlciBkZWZpbmVkXG4gICAgaWYoc2NoZW1hLiRyZWYpe1xuICAgICAgdmFyIHJlc29sdmVkVXJpID0gdXJpbGliLnJlc29sdmUoYmFzZXVyaSwgc2NoZW1hLiRyZWYpO1xuICAgICAgcmVmW3Jlc29sdmVkVXJpXSA9IHJlZltyZXNvbHZlZFVyaV0gPyByZWZbcmVzb2x2ZWRVcmldKzEgOiAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaWQgPSBzY2hlbWEuJGlkIHx8IHNjaGVtYS5pZDtcbiAgICB2YXIgb3VyQmFzZSA9IGlkID8gdXJpbGliLnJlc29sdmUoYmFzZXVyaSwgaWQpIDogYmFzZXVyaTtcbiAgICBpZiAob3VyQmFzZSkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBmcmFnbWVudCwgYXBwZW5kIGFuIGVtcHR5IG9uZVxuICAgICAgaWYob3VyQmFzZS5pbmRleE9mKCcjJyk8MCkgb3VyQmFzZSArPSAnIyc7XG4gICAgICBpZihmb3VuZFtvdXJCYXNlXSl7XG4gICAgICAgIGlmKCFoZWxwZXJzLmRlZXBDb21wYXJlU3RyaWN0KGZvdW5kW291ckJhc2VdLCBzY2hlbWEpKXtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NjaGVtYSA8JytvdXJCYXNlKyc+IGFscmVhZHkgZXhpc3RzIHdpdGggZGlmZmVyZW50IGRlZmluaXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRbb3VyQmFzZV07XG4gICAgICB9XG4gICAgICBmb3VuZFtvdXJCYXNlXSA9IHNjaGVtYTtcbiAgICAgIC8vIHN0cmlwIHRyYWlsaW5nIGZyYWdtZW50XG4gICAgICBpZihvdXJCYXNlW291ckJhc2UubGVuZ3RoLTFdPT0nIycpe1xuICAgICAgICBmb3VuZFtvdXJCYXNlLnN1YnN0cmluZygwLCBvdXJCYXNlLmxlbmd0aC0xKV0gPSBzY2hlbWE7XG4gICAgICB9XG4gICAgfVxuICAgIHNjYW5BcnJheShvdXJCYXNlKycvaXRlbXMnLCAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpP3NjaGVtYS5pdGVtczpbc2NoZW1hLml0ZW1zXSkpO1xuICAgIHNjYW5BcnJheShvdXJCYXNlKycvZXh0ZW5kcycsIChBcnJheS5pc0FycmF5KHNjaGVtYS5leHRlbmRzKT9zY2hlbWEuZXh0ZW5kczpbc2NoZW1hLmV4dGVuZHNdKSk7XG4gICAgc2NhblNjaGVtYShvdXJCYXNlKycvYWRkaXRpb25hbEl0ZW1zJywgc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyk7XG4gICAgc2Nhbk9iamVjdChvdXJCYXNlKycvcHJvcGVydGllcycsIHNjaGVtYS5wcm9wZXJ0aWVzKTtcbiAgICBzY2FuU2NoZW1hKG91ckJhc2UrJy9hZGRpdGlvbmFsUHJvcGVydGllcycsIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyk7XG4gICAgc2Nhbk9iamVjdChvdXJCYXNlKycvZGVmaW5pdGlvbnMnLCBzY2hlbWEuZGVmaW5pdGlvbnMpO1xuICAgIHNjYW5PYmplY3Qob3VyQmFzZSsnL3BhdHRlcm5Qcm9wZXJ0aWVzJywgc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKTtcbiAgICBzY2FuT2JqZWN0KG91ckJhc2UrJy9kZXBlbmRlbmNpZXMnLCBzY2hlbWEuZGVwZW5kZW5jaWVzKTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL2Rpc2FsbG93Jywgc2NoZW1hLmRpc2FsbG93KTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL2FsbE9mJywgc2NoZW1hLmFsbE9mKTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL2FueU9mJywgc2NoZW1hLmFueU9mKTtcbiAgICBzY2FuQXJyYXkob3VyQmFzZSsnL29uZU9mJywgc2NoZW1hLm9uZU9mKTtcbiAgICBzY2FuU2NoZW1hKG91ckJhc2UrJy9ub3QnLCBzY2hlbWEubm90KTtcbiAgfVxuICBmdW5jdGlvbiBzY2FuQXJyYXkoYmFzZXVyaSwgc2NoZW1hcyl7XG4gICAgaWYoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHJldHVybjtcbiAgICBmb3IodmFyIGk9MDsgaTxzY2hlbWFzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHNjYW5TY2hlbWEoYmFzZXVyaSsnLycraSwgc2NoZW1hc1tpXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNjYW5PYmplY3QoYmFzZXVyaSwgc2NoZW1hcyl7XG4gICAgaWYoIXNjaGVtYXMgfHwgdHlwZW9mIHNjaGVtYXMhPSdvYmplY3QnKSByZXR1cm47XG4gICAgZm9yKHZhciBwIGluIHNjaGVtYXMpe1xuICAgICAgc2NhblNjaGVtYShiYXNldXJpKycvJytwLCBzY2hlbWFzW3BdKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZm91bmQgPSB7fTtcbiAgdmFyIHJlZiA9IHt9O1xuICBzY2FuU2NoZW1hKGJhc2UsIHNjaGVtYSk7XG4gIHJldHVybiBuZXcgU2NoZW1hU2NhblJlc3VsdChmb3VuZCwgcmVmKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31287\n")},43058:function(module,__unused_webpack_exports,__webpack_require__){"use strict";eval("\n\nvar urilib = __webpack_require__(8575);\n\nvar attribute = __webpack_require__(96481);\nvar helpers = __webpack_require__(59177);\nvar scanSchema = (__webpack_require__(31287).scan);\nvar ValidatorResult = helpers.ValidatorResult;\nvar ValidatorResultError = helpers.ValidatorResultError;\nvar SchemaError = helpers.SchemaError;\nvar SchemaContext = helpers.SchemaContext;\n//var anonymousBase = 'vnd.jsonschema:///';\nvar anonymousBase = '/';\n\n/**\n * Creates a new Validator object\n * @name Validator\n * @constructor\n */\nvar Validator = function Validator () {\n  // Allow a validator instance to override global custom formats or to have their\n  // own custom formats.\n  this.customFormats = Object.create(Validator.prototype.customFormats);\n  this.schemas = {};\n  this.unresolvedRefs = [];\n\n  // Use Object.create to make this extensible without Validator instances stepping on each other's toes.\n  this.types = Object.create(types);\n  this.attributes = Object.create(attribute.validators);\n};\n\n// Allow formats to be registered globally.\nValidator.prototype.customFormats = {};\n\n// Hint at the presence of a property\nValidator.prototype.schemas = null;\nValidator.prototype.types = null;\nValidator.prototype.attributes = null;\nValidator.prototype.unresolvedRefs = null;\n\n/**\n * Adds a schema with a certain urn to the Validator instance.\n * @param schema\n * @param urn\n * @return {Object}\n */\nValidator.prototype.addSchema = function addSchema (schema, base) {\n  var self = this;\n  if (!schema) {\n    return null;\n  }\n  var scan = scanSchema(base||anonymousBase, schema);\n  var ourUri = base || schema.$id || schema.id;\n  for(var uri in scan.id){\n    this.schemas[uri] = scan.id[uri];\n  }\n  for(var uri in scan.ref){\n    // If this schema is already defined, it will be filtered out by the next step\n    this.unresolvedRefs.push(uri);\n  }\n  // Remove newly defined schemas from unresolvedRefs\n  this.unresolvedRefs = this.unresolvedRefs.filter(function(uri){\n    return typeof self.schemas[uri]==='undefined';\n  });\n  return this.schemas[ourUri];\n};\n\nValidator.prototype.addSubSchemaArray = function addSubSchemaArray(baseuri, schemas) {\n  if(!Array.isArray(schemas)) return;\n  for(var i=0; i<schemas.length; i++){\n    this.addSubSchema(baseuri, schemas[i]);\n  }\n};\n\nValidator.prototype.addSubSchemaObject = function addSubSchemaArray(baseuri, schemas) {\n  if(!schemas || typeof schemas!='object') return;\n  for(var p in schemas){\n    this.addSubSchema(baseuri, schemas[p]);\n  }\n};\n\n\n\n/**\n * Sets all the schemas of the Validator instance.\n * @param schemas\n */\nValidator.prototype.setSchemas = function setSchemas (schemas) {\n  this.schemas = schemas;\n};\n\n/**\n * Returns the schema of a certain urn\n * @param urn\n */\nValidator.prototype.getSchema = function getSchema (urn) {\n  return this.schemas[urn];\n};\n\n/**\n * Validates instance against the provided schema\n * @param instance\n * @param schema\n * @param [options]\n * @param [ctx]\n * @return {Array}\n */\nValidator.prototype.validate = function validate (instance, schema, options, ctx) {\n  if((typeof schema !== 'boolean' && typeof schema !== 'object') || schema === null){\n    throw new SchemaError('Expected `schema` to be an object or boolean');\n  }\n  if (!options) {\n    options = {};\n  }\n  // This section indexes subschemas in the provided schema, so they don't need to be added with Validator#addSchema\n  // This will work so long as the function at uri.resolve() will resolve a relative URI to a relative URI\n  var id = schema.$id || schema.id;\n  var base = urilib.resolve(options.base||anonymousBase, id||'');\n  if(!ctx){\n    ctx = new SchemaContext(schema, options, [], base, Object.create(this.schemas));\n    if (!ctx.schemas[base]) {\n      ctx.schemas[base] = schema;\n    }\n    var found = scanSchema(base, schema);\n    for(var n in found.id){\n      var sch = found.id[n];\n      ctx.schemas[n] = sch;\n    }\n  }\n  if(options.required && instance===undefined){\n    var result = new ValidatorResult(instance, schema, options, ctx);\n    result.addError('is required, but is undefined');\n    return result;\n  }\n  var result = this.validateSchema(instance, schema, options, ctx);\n  if (!result) {\n    throw new Error('Result undefined');\n  }else if(options.throwAll && result.errors.length){\n    throw new ValidatorResultError(result);\n  }\n  return result;\n};\n\n/**\n* @param Object schema\n* @return mixed schema uri or false\n*/\nfunction shouldResolve(schema) {\n  var ref = (typeof schema === 'string') ? schema : schema.$ref;\n  if (typeof ref=='string') return ref;\n  return false;\n}\n\n/**\n * Validates an instance against the schema (the actual work horse)\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @private\n * @return {ValidatorResult}\n */\nValidator.prototype.validateSchema = function validateSchema (instance, schema, options, ctx) {\n  var result = new ValidatorResult(instance, schema, options, ctx);\n\n  // Support for the true/false schemas\n  if(typeof schema==='boolean') {\n    if(schema===true){\n      // `true` is always valid\n      schema = {};\n    }else if(schema===false){\n      // `false` is always invalid\n      schema = {type: []};\n    }\n  }else if(!schema){\n    // This might be a string\n    throw new Error(\"schema is undefined\");\n  }\n\n  if (schema['extends']) {\n    if (Array.isArray(schema['extends'])) {\n      var schemaobj = {schema: schema, ctx: ctx};\n      schema['extends'].forEach(this.schemaTraverser.bind(this, schemaobj));\n      schema = schemaobj.schema;\n      schemaobj.schema = null;\n      schemaobj.ctx = null;\n      schemaobj = null;\n    } else {\n      schema = helpers.deepMerge(schema, this.superResolve(schema['extends'], ctx));\n    }\n  }\n\n  // If passed a string argument, load that schema URI\n  var switchSchema = shouldResolve(schema);\n  if (switchSchema) {\n    var resolved = this.resolve(schema, switchSchema, ctx);\n    var subctx = new SchemaContext(resolved.subschema, options, ctx.path, resolved.switchSchema, ctx.schemas);\n    return this.validateSchema(instance, resolved.subschema, options, subctx);\n  }\n\n  var skipAttributes = options && options.skipAttributes || [];\n  // Validate each schema attribute against the instance\n  for (var key in schema) {\n    if (!attribute.ignoreProperties[key] && skipAttributes.indexOf(key) < 0) {\n      var validatorErr = null;\n      var validator = this.attributes[key];\n      if (validator) {\n        validatorErr = validator.call(this, instance, schema, options, ctx);\n      } else if (options.allowUnknownAttributes === false) {\n        // This represents an error with the schema itself, not an invalid instance\n        throw new SchemaError(\"Unsupported attribute: \" + key, schema);\n      }\n      if (validatorErr) {\n        result.importErrors(validatorErr);\n      }\n    }\n  }\n\n  if (typeof options.rewrite == 'function') {\n    var value = options.rewrite.call(this, instance, schema, options, ctx);\n    result.instance = value;\n  }\n  return result;\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.schemaTraverser = function schemaTraverser (schemaobj, s) {\n  schemaobj.schema = helpers.deepMerge(schemaobj.schema, this.superResolve(s, schemaobj.ctx));\n};\n\n/**\n* @private\n* @param Object schema\n* @param SchemaContext ctx\n* @returns Object schema or resolved schema\n*/\nValidator.prototype.superResolve = function superResolve (schema, ctx) {\n  var ref = shouldResolve(schema);\n  if(ref) {\n    return this.resolve(schema, ref, ctx).subschema;\n  }\n  return schema;\n};\n\n/**\n* @private\n* @param Object schema\n* @param Object switchSchema\n* @param SchemaContext ctx\n* @return Object resolved schemas {subschema:String, switchSchema: String}\n* @throws SchemaError\n*/\nValidator.prototype.resolve = function resolve (schema, switchSchema, ctx) {\n  switchSchema = ctx.resolve(switchSchema);\n  // First see if the schema exists under the provided URI\n  if (ctx.schemas[switchSchema]) {\n    return {subschema: ctx.schemas[switchSchema], switchSchema: switchSchema};\n  }\n  // Else try walking the property pointer\n  var parsed = urilib.parse(switchSchema);\n  var fragment = parsed && parsed.hash;\n  var document = fragment && fragment.length && switchSchema.substr(0, switchSchema.length - fragment.length);\n  if (!document || !ctx.schemas[document]) {\n    throw new SchemaError(\"no such schema <\" + switchSchema + \">\", schema);\n  }\n  var subschema = helpers.objectGetPath(ctx.schemas[document], fragment.substr(1));\n  if(subschema===undefined){\n    throw new SchemaError(\"no such schema \" + fragment + \" located in <\" + document + \">\", schema);\n  }\n  return {subschema: subschema, switchSchema: switchSchema};\n};\n\n/**\n * Tests whether the instance if of a certain type.\n * @private\n * @param instance\n * @param schema\n * @param options\n * @param ctx\n * @param type\n * @return {boolean}\n */\nValidator.prototype.testType = function validateType (instance, schema, options, ctx, type) {\n  if(type===undefined){\n    return;\n  }else if(type===null){\n    throw new SchemaError('Unexpected null in \"type\" keyword');\n  }\n  if (typeof this.types[type] == 'function') {\n    return this.types[type].call(this, instance);\n  }\n  if (type && typeof type == 'object') {\n    var res = this.validateSchema(instance, type, options, ctx);\n    return res === undefined || !(res && res.errors.length);\n  }\n  // Undefined or properties not on the list are acceptable, same as not being defined\n  return true;\n};\n\nvar types = Validator.prototype.types = {};\ntypes.string = function testString (instance) {\n  return typeof instance == 'string';\n};\ntypes.number = function testNumber (instance) {\n  // isFinite returns false for NaN, Infinity, and -Infinity\n  return typeof instance == 'number' && isFinite(instance);\n};\ntypes.integer = function testInteger (instance) {\n  return (typeof instance == 'number') && instance % 1 === 0;\n};\ntypes.boolean = function testBoolean (instance) {\n  return typeof instance == 'boolean';\n};\ntypes.array = function testArray (instance) {\n  return Array.isArray(instance);\n};\ntypes['null'] = function testNull (instance) {\n  return instance === null;\n};\ntypes.date = function testDate (instance) {\n  return instance instanceof Date;\n};\ntypes.any = function testAny (instance) {\n  return true;\n};\ntypes.object = function testObject (instance) {\n  // TODO: fix this - see #15\n  return instance && (typeof instance === 'object') && !(Array.isArray(instance)) && !(instance instanceof Date);\n};\n\nmodule.exports = Validator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMwNTguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLElBQUs7O0FBRTFCLGdCQUFnQixtQkFBTyxDQUFDLEtBQWE7QUFDckMsY0FBYyxtQkFBTyxDQUFDLEtBQVc7QUFDakMsaUJBQWlCLGlDQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ucHdkLW51aS8uL25vZGVfbW9kdWxlcy9qc29uc2NoZW1hL2xpYi92YWxpZGF0b3IuanM/Mjk0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1cmlsaWIgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIGF0dHJpYnV0ZSA9IHJlcXVpcmUoJy4vYXR0cmlidXRlJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xudmFyIHNjYW5TY2hlbWEgPSByZXF1aXJlKCcuL3NjYW4nKS5zY2FuO1xudmFyIFZhbGlkYXRvclJlc3VsdCA9IGhlbHBlcnMuVmFsaWRhdG9yUmVzdWx0O1xudmFyIFZhbGlkYXRvclJlc3VsdEVycm9yID0gaGVscGVycy5WYWxpZGF0b3JSZXN1bHRFcnJvcjtcbnZhciBTY2hlbWFFcnJvciA9IGhlbHBlcnMuU2NoZW1hRXJyb3I7XG52YXIgU2NoZW1hQ29udGV4dCA9IGhlbHBlcnMuU2NoZW1hQ29udGV4dDtcbi8vdmFyIGFub255bW91c0Jhc2UgPSAndm5kLmpzb25zY2hlbWE6Ly8vJztcbnZhciBhbm9ueW1vdXNCYXNlID0gJy8nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVmFsaWRhdG9yIG9iamVjdFxuICogQG5hbWUgVmFsaWRhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFZhbGlkYXRvciA9IGZ1bmN0aW9uIFZhbGlkYXRvciAoKSB7XG4gIC8vIEFsbG93IGEgdmFsaWRhdG9yIGluc3RhbmNlIHRvIG92ZXJyaWRlIGdsb2JhbCBjdXN0b20gZm9ybWF0cyBvciB0byBoYXZlIHRoZWlyXG4gIC8vIG93biBjdXN0b20gZm9ybWF0cy5cbiAgdGhpcy5jdXN0b21Gb3JtYXRzID0gT2JqZWN0LmNyZWF0ZShWYWxpZGF0b3IucHJvdG90eXBlLmN1c3RvbUZvcm1hdHMpO1xuICB0aGlzLnNjaGVtYXMgPSB7fTtcbiAgdGhpcy51bnJlc29sdmVkUmVmcyA9IFtdO1xuXG4gIC8vIFVzZSBPYmplY3QuY3JlYXRlIHRvIG1ha2UgdGhpcyBleHRlbnNpYmxlIHdpdGhvdXQgVmFsaWRhdG9yIGluc3RhbmNlcyBzdGVwcGluZyBvbiBlYWNoIG90aGVyJ3MgdG9lcy5cbiAgdGhpcy50eXBlcyA9IE9iamVjdC5jcmVhdGUodHlwZXMpO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBPYmplY3QuY3JlYXRlKGF0dHJpYnV0ZS52YWxpZGF0b3JzKTtcbn07XG5cbi8vIEFsbG93IGZvcm1hdHMgdG8gYmUgcmVnaXN0ZXJlZCBnbG9iYWxseS5cblZhbGlkYXRvci5wcm90b3R5cGUuY3VzdG9tRm9ybWF0cyA9IHt9O1xuXG4vLyBIaW50IGF0IHRoZSBwcmVzZW5jZSBvZiBhIHByb3BlcnR5XG5WYWxpZGF0b3IucHJvdG90eXBlLnNjaGVtYXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS50eXBlcyA9IG51bGw7XG5WYWxpZGF0b3IucHJvdG90eXBlLmF0dHJpYnV0ZXMgPSBudWxsO1xuVmFsaWRhdG9yLnByb3RvdHlwZS51bnJlc29sdmVkUmVmcyA9IG51bGw7XG5cbi8qKlxuICogQWRkcyBhIHNjaGVtYSB3aXRoIGEgY2VydGFpbiB1cm4gdG8gdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSB1cm5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5hZGRTY2hlbWEgPSBmdW5jdGlvbiBhZGRTY2hlbWEgKHNjaGVtYSwgYmFzZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghc2NoZW1hKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNjYW4gPSBzY2FuU2NoZW1hKGJhc2V8fGFub255bW91c0Jhc2UsIHNjaGVtYSk7XG4gIHZhciBvdXJVcmkgPSBiYXNlIHx8IHNjaGVtYS4kaWQgfHwgc2NoZW1hLmlkO1xuICBmb3IodmFyIHVyaSBpbiBzY2FuLmlkKXtcbiAgICB0aGlzLnNjaGVtYXNbdXJpXSA9IHNjYW4uaWRbdXJpXTtcbiAgfVxuICBmb3IodmFyIHVyaSBpbiBzY2FuLnJlZil7XG4gICAgLy8gSWYgdGhpcyBzY2hlbWEgaXMgYWxyZWFkeSBkZWZpbmVkLCBpdCB3aWxsIGJlIGZpbHRlcmVkIG91dCBieSB0aGUgbmV4dCBzdGVwXG4gICAgdGhpcy51bnJlc29sdmVkUmVmcy5wdXNoKHVyaSk7XG4gIH1cbiAgLy8gUmVtb3ZlIG5ld2x5IGRlZmluZWQgc2NoZW1hcyBmcm9tIHVucmVzb2x2ZWRSZWZzXG4gIHRoaXMudW5yZXNvbHZlZFJlZnMgPSB0aGlzLnVucmVzb2x2ZWRSZWZzLmZpbHRlcihmdW5jdGlvbih1cmkpe1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZi5zY2hlbWFzW3VyaV09PT0ndW5kZWZpbmVkJztcbiAgfSk7XG4gIHJldHVybiB0aGlzLnNjaGVtYXNbb3VyVXJpXTtcbn07XG5cblZhbGlkYXRvci5wcm90b3R5cGUuYWRkU3ViU2NoZW1hQXJyYXkgPSBmdW5jdGlvbiBhZGRTdWJTY2hlbWFBcnJheShiYXNldXJpLCBzY2hlbWFzKSB7XG4gIGlmKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSByZXR1cm47XG4gIGZvcih2YXIgaT0wOyBpPHNjaGVtYXMubGVuZ3RoOyBpKyspe1xuICAgIHRoaXMuYWRkU3ViU2NoZW1hKGJhc2V1cmksIHNjaGVtYXNbaV0pO1xuICB9XG59O1xuXG5WYWxpZGF0b3IucHJvdG90eXBlLmFkZFN1YlNjaGVtYU9iamVjdCA9IGZ1bmN0aW9uIGFkZFN1YlNjaGVtYUFycmF5KGJhc2V1cmksIHNjaGVtYXMpIHtcbiAgaWYoIXNjaGVtYXMgfHwgdHlwZW9mIHNjaGVtYXMhPSdvYmplY3QnKSByZXR1cm47XG4gIGZvcih2YXIgcCBpbiBzY2hlbWFzKXtcbiAgICB0aGlzLmFkZFN1YlNjaGVtYShiYXNldXJpLCBzY2hlbWFzW3BdKTtcbiAgfVxufTtcblxuXG5cbi8qKlxuICogU2V0cyBhbGwgdGhlIHNjaGVtYXMgb2YgdGhlIFZhbGlkYXRvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSBzY2hlbWFzXG4gKi9cblZhbGlkYXRvci5wcm90b3R5cGUuc2V0U2NoZW1hcyA9IGZ1bmN0aW9uIHNldFNjaGVtYXMgKHNjaGVtYXMpIHtcbiAgdGhpcy5zY2hlbWFzID0gc2NoZW1hcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2NoZW1hIG9mIGEgY2VydGFpbiB1cm5cbiAqIEBwYXJhbSB1cm5cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRTY2hlbWEgPSBmdW5jdGlvbiBnZXRTY2hlbWEgKHVybikge1xuICByZXR1cm4gdGhpcy5zY2hlbWFzW3Vybl07XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlcyBpbnN0YW5jZSBhZ2FpbnN0IHRoZSBwcm92aWRlZCBzY2hlbWFcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIFtvcHRpb25zXVxuICogQHBhcmFtIFtjdHhdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpIHtcbiAgaWYoKHR5cGVvZiBzY2hlbWEgIT09ICdib29sZWFuJyAmJiB0eXBlb2Ygc2NoZW1hICE9PSAnb2JqZWN0JykgfHwgc2NoZW1hID09PSBudWxsKXtcbiAgICB0aHJvdyBuZXcgU2NoZW1hRXJyb3IoJ0V4cGVjdGVkIGBzY2hlbWFgIHRvIGJlIGFuIG9iamVjdCBvciBib29sZWFuJyk7XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIC8vIFRoaXMgc2VjdGlvbiBpbmRleGVzIHN1YnNjaGVtYXMgaW4gdGhlIHByb3ZpZGVkIHNjaGVtYSwgc28gdGhleSBkb24ndCBuZWVkIHRvIGJlIGFkZGVkIHdpdGggVmFsaWRhdG9yI2FkZFNjaGVtYVxuICAvLyBUaGlzIHdpbGwgd29yayBzbyBsb25nIGFzIHRoZSBmdW5jdGlvbiBhdCB1cmkucmVzb2x2ZSgpIHdpbGwgcmVzb2x2ZSBhIHJlbGF0aXZlIFVSSSB0byBhIHJlbGF0aXZlIFVSSVxuICB2YXIgaWQgPSBzY2hlbWEuJGlkIHx8IHNjaGVtYS5pZDtcbiAgdmFyIGJhc2UgPSB1cmlsaWIucmVzb2x2ZShvcHRpb25zLmJhc2V8fGFub255bW91c0Jhc2UsIGlkfHwnJyk7XG4gIGlmKCFjdHgpe1xuICAgIGN0eCA9IG5ldyBTY2hlbWFDb250ZXh0KHNjaGVtYSwgb3B0aW9ucywgW10sIGJhc2UsIE9iamVjdC5jcmVhdGUodGhpcy5zY2hlbWFzKSk7XG4gICAgaWYgKCFjdHguc2NoZW1hc1tiYXNlXSkge1xuICAgICAgY3R4LnNjaGVtYXNbYmFzZV0gPSBzY2hlbWE7XG4gICAgfVxuICAgIHZhciBmb3VuZCA9IHNjYW5TY2hlbWEoYmFzZSwgc2NoZW1hKTtcbiAgICBmb3IodmFyIG4gaW4gZm91bmQuaWQpe1xuICAgICAgdmFyIHNjaCA9IGZvdW5kLmlkW25dO1xuICAgICAgY3R4LnNjaGVtYXNbbl0gPSBzY2g7XG4gICAgfVxuICB9XG4gIGlmKG9wdGlvbnMucmVxdWlyZWQgJiYgaW5zdGFuY2U9PT11bmRlZmluZWQpe1xuICAgIHZhciByZXN1bHQgPSBuZXcgVmFsaWRhdG9yUmVzdWx0KGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgcmVzdWx0LmFkZEVycm9yKCdpcyByZXF1aXJlZCwgYnV0IGlzIHVuZGVmaW5lZCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3VsdCB1bmRlZmluZWQnKTtcbiAgfWVsc2UgaWYob3B0aW9ucy50aHJvd0FsbCAmJiByZXN1bHQuZXJyb3JzLmxlbmd0aCl7XG4gICAgdGhyb3cgbmV3IFZhbGlkYXRvclJlc3VsdEVycm9yKHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcmV0dXJuIG1peGVkIHNjaGVtYSB1cmkgb3IgZmFsc2VcbiovXG5mdW5jdGlvbiBzaG91bGRSZXNvbHZlKHNjaGVtYSkge1xuICB2YXIgcmVmID0gKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnKSA/IHNjaGVtYSA6IHNjaGVtYS4kcmVmO1xuICBpZiAodHlwZW9mIHJlZj09J3N0cmluZycpIHJldHVybiByZWY7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYW4gaW5zdGFuY2UgYWdhaW5zdCB0aGUgc2NoZW1hICh0aGUgYWN0dWFsIHdvcmsgaG9yc2UpXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gY3R4XG4gKiBAcHJpdmF0ZVxuICogQHJldHVybiB7VmFsaWRhdG9yUmVzdWx0fVxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlU2NoZW1hID0gZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEgKGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IFZhbGlkYXRvclJlc3VsdChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgpO1xuXG4gIC8vIFN1cHBvcnQgZm9yIHRoZSB0cnVlL2ZhbHNlIHNjaGVtYXNcbiAgaWYodHlwZW9mIHNjaGVtYT09PSdib29sZWFuJykge1xuICAgIGlmKHNjaGVtYT09PXRydWUpe1xuICAgICAgLy8gYHRydWVgIGlzIGFsd2F5cyB2YWxpZFxuICAgICAgc2NoZW1hID0ge307XG4gICAgfWVsc2UgaWYoc2NoZW1hPT09ZmFsc2Upe1xuICAgICAgLy8gYGZhbHNlYCBpcyBhbHdheXMgaW52YWxpZFxuICAgICAgc2NoZW1hID0ge3R5cGU6IFtdfTtcbiAgICB9XG4gIH1lbHNlIGlmKCFzY2hlbWEpe1xuICAgIC8vIFRoaXMgbWlnaHQgYmUgYSBzdHJpbmdcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgaXMgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgaWYgKHNjaGVtYVsnZXh0ZW5kcyddKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hWydleHRlbmRzJ10pKSB7XG4gICAgICB2YXIgc2NoZW1hb2JqID0ge3NjaGVtYTogc2NoZW1hLCBjdHg6IGN0eH07XG4gICAgICBzY2hlbWFbJ2V4dGVuZHMnXS5mb3JFYWNoKHRoaXMuc2NoZW1hVHJhdmVyc2VyLmJpbmQodGhpcywgc2NoZW1hb2JqKSk7XG4gICAgICBzY2hlbWEgPSBzY2hlbWFvYmouc2NoZW1hO1xuICAgICAgc2NoZW1hb2JqLnNjaGVtYSA9IG51bGw7XG4gICAgICBzY2hlbWFvYmouY3R4ID0gbnVsbDtcbiAgICAgIHNjaGVtYW9iaiA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVtYSA9IGhlbHBlcnMuZGVlcE1lcmdlKHNjaGVtYSwgdGhpcy5zdXBlclJlc29sdmUoc2NoZW1hWydleHRlbmRzJ10sIGN0eCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHBhc3NlZCBhIHN0cmluZyBhcmd1bWVudCwgbG9hZCB0aGF0IHNjaGVtYSBVUklcbiAgdmFyIHN3aXRjaFNjaGVtYSA9IHNob3VsZFJlc29sdmUoc2NoZW1hKTtcbiAgaWYgKHN3aXRjaFNjaGVtYSkge1xuICAgIHZhciByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShzY2hlbWEsIHN3aXRjaFNjaGVtYSwgY3R4KTtcbiAgICB2YXIgc3ViY3R4ID0gbmV3IFNjaGVtYUNvbnRleHQocmVzb2x2ZWQuc3Vic2NoZW1hLCBvcHRpb25zLCBjdHgucGF0aCwgcmVzb2x2ZWQuc3dpdGNoU2NoZW1hLCBjdHguc2NoZW1hcyk7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTY2hlbWEoaW5zdGFuY2UsIHJlc29sdmVkLnN1YnNjaGVtYSwgb3B0aW9ucywgc3ViY3R4KTtcbiAgfVxuXG4gIHZhciBza2lwQXR0cmlidXRlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQXR0cmlidXRlcyB8fCBbXTtcbiAgLy8gVmFsaWRhdGUgZWFjaCBzY2hlbWEgYXR0cmlidXRlIGFnYWluc3QgdGhlIGluc3RhbmNlXG4gIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZS5pZ25vcmVQcm9wZXJ0aWVzW2tleV0gJiYgc2tpcEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgdmFyIHZhbGlkYXRvckVyciA9IG51bGw7XG4gICAgICB2YXIgdmFsaWRhdG9yID0gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICAgIHZhbGlkYXRvckVyciA9IHZhbGlkYXRvci5jYWxsKHRoaXMsIGluc3RhbmNlLCBzY2hlbWEsIG9wdGlvbnMsIGN0eCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxsb3dVbmtub3duQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gVGhpcyByZXByZXNlbnRzIGFuIGVycm9yIHdpdGggdGhlIHNjaGVtYSBpdHNlbGYsIG5vdCBhbiBpbnZhbGlkIGluc3RhbmNlXG4gICAgICAgIHRocm93IG5ldyBTY2hlbWFFcnJvcihcIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZTogXCIgKyBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdG9yRXJyKSB7XG4gICAgICAgIHJlc3VsdC5pbXBvcnRFcnJvcnModmFsaWRhdG9yRXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMucmV3cml0ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHZhbHVlID0gb3B0aW9ucy5yZXdyaXRlLmNhbGwodGhpcywgaW5zdGFuY2UsIHNjaGVtYSwgb3B0aW9ucywgY3R4KTtcbiAgICByZXN1bHQuaW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4qIEBwcml2YXRlXG4qIEBwYXJhbSBPYmplY3Qgc2NoZW1hXG4qIEBwYXJhbSBTY2hlbWFDb250ZXh0IGN0eFxuKiBAcmV0dXJucyBPYmplY3Qgc2NoZW1hIG9yIHJlc29sdmVkIHNjaGVtYVxuKi9cblZhbGlkYXRvci5wcm90b3R5cGUuc2NoZW1hVHJhdmVyc2VyID0gZnVuY3Rpb24gc2NoZW1hVHJhdmVyc2VyIChzY2hlbWFvYmosIHMpIHtcbiAgc2NoZW1hb2JqLnNjaGVtYSA9IGhlbHBlcnMuZGVlcE1lcmdlKHNjaGVtYW9iai5zY2hlbWEsIHRoaXMuc3VwZXJSZXNvbHZlKHMsIHNjaGVtYW9iai5jdHgpKTtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcGFyYW0gU2NoZW1hQ29udGV4dCBjdHhcbiogQHJldHVybnMgT2JqZWN0IHNjaGVtYSBvciByZXNvbHZlZCBzY2hlbWFcbiovXG5WYWxpZGF0b3IucHJvdG90eXBlLnN1cGVyUmVzb2x2ZSA9IGZ1bmN0aW9uIHN1cGVyUmVzb2x2ZSAoc2NoZW1hLCBjdHgpIHtcbiAgdmFyIHJlZiA9IHNob3VsZFJlc29sdmUoc2NoZW1hKTtcbiAgaWYocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShzY2hlbWEsIHJlZiwgY3R4KS5zdWJzY2hlbWE7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn07XG5cbi8qKlxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0gT2JqZWN0IHNjaGVtYVxuKiBAcGFyYW0gT2JqZWN0IHN3aXRjaFNjaGVtYVxuKiBAcGFyYW0gU2NoZW1hQ29udGV4dCBjdHhcbiogQHJldHVybiBPYmplY3QgcmVzb2x2ZWQgc2NoZW1hcyB7c3Vic2NoZW1hOlN0cmluZywgc3dpdGNoU2NoZW1hOiBTdHJpbmd9XG4qIEB0aHJvd3MgU2NoZW1hRXJyb3JcbiovXG5WYWxpZGF0b3IucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChzY2hlbWEsIHN3aXRjaFNjaGVtYSwgY3R4KSB7XG4gIHN3aXRjaFNjaGVtYSA9IGN0eC5yZXNvbHZlKHN3aXRjaFNjaGVtYSk7XG4gIC8vIEZpcnN0IHNlZSBpZiB0aGUgc2NoZW1hIGV4aXN0cyB1bmRlciB0aGUgcHJvdmlkZWQgVVJJXG4gIGlmIChjdHguc2NoZW1hc1tzd2l0Y2hTY2hlbWFdKSB7XG4gICAgcmV0dXJuIHtzdWJzY2hlbWE6IGN0eC5zY2hlbWFzW3N3aXRjaFNjaGVtYV0sIHN3aXRjaFNjaGVtYTogc3dpdGNoU2NoZW1hfTtcbiAgfVxuICAvLyBFbHNlIHRyeSB3YWxraW5nIHRoZSBwcm9wZXJ0eSBwb2ludGVyXG4gIHZhciBwYXJzZWQgPSB1cmlsaWIucGFyc2Uoc3dpdGNoU2NoZW1hKTtcbiAgdmFyIGZyYWdtZW50ID0gcGFyc2VkICYmIHBhcnNlZC5oYXNoO1xuICB2YXIgZG9jdW1lbnQgPSBmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGggJiYgc3dpdGNoU2NoZW1hLnN1YnN0cigwLCBzd2l0Y2hTY2hlbWEubGVuZ3RoIC0gZnJhZ21lbnQubGVuZ3RoKTtcbiAgaWYgKCFkb2N1bWVudCB8fCAhY3R4LnNjaGVtYXNbZG9jdW1lbnRdKSB7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKFwibm8gc3VjaCBzY2hlbWEgPFwiICsgc3dpdGNoU2NoZW1hICsgXCI+XCIsIHNjaGVtYSk7XG4gIH1cbiAgdmFyIHN1YnNjaGVtYSA9IGhlbHBlcnMub2JqZWN0R2V0UGF0aChjdHguc2NoZW1hc1tkb2N1bWVudF0sIGZyYWdtZW50LnN1YnN0cigxKSk7XG4gIGlmKHN1YnNjaGVtYT09PXVuZGVmaW5lZCl7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKFwibm8gc3VjaCBzY2hlbWEgXCIgKyBmcmFnbWVudCArIFwiIGxvY2F0ZWQgaW4gPFwiICsgZG9jdW1lbnQgKyBcIj5cIiwgc2NoZW1hKTtcbiAgfVxuICByZXR1cm4ge3N1YnNjaGVtYTogc3Vic2NoZW1hLCBzd2l0Y2hTY2hlbWE6IHN3aXRjaFNjaGVtYX07XG59O1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIGluc3RhbmNlIGlmIG9mIGEgY2VydGFpbiB0eXBlLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBpbnN0YW5jZVxuICogQHBhcmFtIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBjdHhcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5WYWxpZGF0b3IucHJvdG90eXBlLnRlc3RUeXBlID0gZnVuY3Rpb24gdmFsaWRhdGVUeXBlIChpbnN0YW5jZSwgc2NoZW1hLCBvcHRpb25zLCBjdHgsIHR5cGUpIHtcbiAgaWYodHlwZT09PXVuZGVmaW5lZCl7XG4gICAgcmV0dXJuO1xuICB9ZWxzZSBpZih0eXBlPT09bnVsbCl7XG4gICAgdGhyb3cgbmV3IFNjaGVtYUVycm9yKCdVbmV4cGVjdGVkIG51bGwgaW4gXCJ0eXBlXCIga2V5d29yZCcpO1xuICB9XG4gIGlmICh0eXBlb2YgdGhpcy50eXBlc1t0eXBlXSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZXNbdHlwZV0uY2FsbCh0aGlzLCBpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKHR5cGUgJiYgdHlwZW9mIHR5cGUgPT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0gdGhpcy52YWxpZGF0ZVNjaGVtYShpbnN0YW5jZSwgdHlwZSwgb3B0aW9ucywgY3R4KTtcbiAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgfHwgIShyZXMgJiYgcmVzLmVycm9ycy5sZW5ndGgpO1xuICB9XG4gIC8vIFVuZGVmaW5lZCBvciBwcm9wZXJ0aWVzIG5vdCBvbiB0aGUgbGlzdCBhcmUgYWNjZXB0YWJsZSwgc2FtZSBhcyBub3QgYmVpbmcgZGVmaW5lZFxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciB0eXBlcyA9IFZhbGlkYXRvci5wcm90b3R5cGUudHlwZXMgPSB7fTtcbnR5cGVzLnN0cmluZyA9IGZ1bmN0aW9uIHRlc3RTdHJpbmcgKGluc3RhbmNlKSB7XG4gIHJldHVybiB0eXBlb2YgaW5zdGFuY2UgPT0gJ3N0cmluZyc7XG59O1xudHlwZXMubnVtYmVyID0gZnVuY3Rpb24gdGVzdE51bWJlciAoaW5zdGFuY2UpIHtcbiAgLy8gaXNGaW5pdGUgcmV0dXJucyBmYWxzZSBmb3IgTmFOLCBJbmZpbml0eSwgYW5kIC1JbmZpbml0eVxuICByZXR1cm4gdHlwZW9mIGluc3RhbmNlID09ICdudW1iZXInICYmIGlzRmluaXRlKGluc3RhbmNlKTtcbn07XG50eXBlcy5pbnRlZ2VyID0gZnVuY3Rpb24gdGVzdEludGVnZXIgKGluc3RhbmNlKSB7XG4gIHJldHVybiAodHlwZW9mIGluc3RhbmNlID09ICdudW1iZXInKSAmJiBpbnN0YW5jZSAlIDEgPT09IDA7XG59O1xudHlwZXMuYm9vbGVhbiA9IGZ1bmN0aW9uIHRlc3RCb29sZWFuIChpbnN0YW5jZSkge1xuICByZXR1cm4gdHlwZW9mIGluc3RhbmNlID09ICdib29sZWFuJztcbn07XG50eXBlcy5hcnJheSA9IGZ1bmN0aW9uIHRlc3RBcnJheSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5zdGFuY2UpO1xufTtcbnR5cGVzWydudWxsJ10gPSBmdW5jdGlvbiB0ZXN0TnVsbCAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlID09PSBudWxsO1xufTtcbnR5cGVzLmRhdGUgPSBmdW5jdGlvbiB0ZXN0RGF0ZSAoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlIGluc3RhbmNlb2YgRGF0ZTtcbn07XG50eXBlcy5hbnkgPSBmdW5jdGlvbiB0ZXN0QW55IChpbnN0YW5jZSkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG50eXBlcy5vYmplY3QgPSBmdW5jdGlvbiB0ZXN0T2JqZWN0IChpbnN0YW5jZSkge1xuICAvLyBUT0RPOiBmaXggdGhpcyAtIHNlZSAjMTVcbiAgcmV0dXJuIGluc3RhbmNlICYmICh0eXBlb2YgaW5zdGFuY2UgPT09ICdvYmplY3QnKSAmJiAhKEFycmF5LmlzQXJyYXkoaW5zdGFuY2UpKSAmJiAhKGluc3RhbmNlIGluc3RhbmNlb2YgRGF0ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43058\n")},62587:function(module){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1ODcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ucHdkLW51aS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanM/NjFjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62587\n")},12361:function(module){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIzNjEuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ucHdkLW51aS8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanM/ZThjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12361\n")},17673:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n\nexports.decode = exports.parse = __webpack_require__(62587);\nexports.encode = exports.stringify = __webpack_require__(12361);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc2NzMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsY0FBYyxHQUFHLDBDQUFtQztBQUNwRCxjQUFjLEdBQUcsOENBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbnB3ZC1udWkvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanM/YWZjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17673\n")},52511:function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports =  true && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule =  true && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn punycode;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {}\n\n}(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI1MTEuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1CQUFtQixLQUEwQjtBQUM3QztBQUNBLGtCQUFrQixLQUF5QjtBQUMzQztBQUNBLHlCQUF5QixxQkFBTSxnQkFBZ0IscUJBQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFVBQVU7QUFDdEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUNBQW1DO0FBQ25FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekIsMENBQTBDLHFCQUFxQjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7O0FBRXZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxpQkFBaUI7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBRVU7QUFDWjtBQUNBLEVBQUUsbUNBQW1CO0FBQ3JCO0FBQ0EsR0FBRztBQUFBLGtHQUFDO0FBQ0osR0FBRyxLQUFLLEVBVU47O0FBRUYsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25wd2QtbnVpLy4vbm9kZV9tb2R1bGVzL3VybC9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanM/YWQ2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///52511\n")},8575:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar punycode = __webpack_require__(52511);\nvar util = __webpack_require__(62502);\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = __webpack_require__(17673);\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU3NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxLQUFVO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxLQUFROztBQUUzQixhQUFhO0FBQ2IsZUFBZTtBQUNmLHFCQUFxQjtBQUNyQixjQUFjOztBQUVkLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUFLOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hELDBDQUEwQyxLQUFLO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsbUJBQU8sQ0FBQyxLQUFhOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ucHdkLW51aS8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzPzBiMTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8575\n")},62502:function(module){"use strict";eval("\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI1MDIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL25wd2QtbnVpLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzPzM1ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62502\n")}}]);